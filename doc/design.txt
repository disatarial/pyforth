/ design.txt  30/12/2015  D.J.Whale

PLAN
overall goal, get to the point we can get an interactive REPL booted.
This will make it easier to test and develop new words.

JUST DONE
SHOW recoded to not use COUNT (as it is no longer a variable)


TODO
Read brodie about TYPE, says something about moved to PAD first??
Then probably rename SHOW as TYPE


--------------------------------------------------------------------------------

---- spec: SPACES

output a specified number of spaces to the output stream
: SPACES ( n -- )

---- design: SPACES

: SPACES                            ( n -- )
    \ loop                          \ ( n)
        DUP                         \ ( n n)
        0BRANCH  7 ( exit)          \ ( n)
        32 EMIT                     \ ( n)
        1 -   ( n-1)                \ ( n)
        BRANCH -9 ( loop)           \ ( n)
    \ exit                          \ ( n)
    DROP                            \ ( )


===============================================================================

----- spec: WORD

: WORD   ( c -- a)

Character on stack indicates the terminator, at end,
a is address of word scanned in.
Ignores initial occurences of the separator char
Moves it to a "temporary buffer of it's own"
count is in first byte preceeding it.
moves the blank at the end also, but does not include it in the count.
Note that the temporary buffer is overwritten very quickly, so you should store
it more permanently as quickly as possible.
WORD will terminate when it hits the end of the input buffer sequence, i.e. the point
the user pressed RETURN

?? What does it do if there are no words left in the input buffer??
  Presumably a points to a zero (zero chars consumed), but what about any separator chars
  that might have been seen, presumably these were before the word, not after the non existent
  word, so length 0 makes sense.


---- design: WORD

# The processing of the inner loops is the same, perhaps refactor
# it out into a helper that just processes based on an arbitrary set of pointers?
# remember that >IN consumes a char by reading it and advancing pointer.
# could pass address of consume routine on DS of course (a callback!)

# probably also worth factoring out writing to the PAD buffer into a helper,
# as that is a common routine that may be used elsewhere in other words.

# does the >IN return a magic number if nothing to consume (e.g. 0?)
# that might simplify the code. Remember it is just a variable, so perhaps
# there is a space for a general purpose "consume next char until end of buffer"
# word, where the in ptr address and the end buffer address are passed in?
# can then pass in addresses relevant to TIB or BLK accordingly.

: WORD \ word ( c -- a)
    0 COUNT !  (note, COUNT is a function, not a variable)
    \ store separator char somewhere
    \ create pointer into PAD buffer, init to 1 (skip over count byte)
    TIB 0BRANCH blk
        \ targettibskiploop
            \ if no chars left in TIB, BRANCH exit
            \ consume next char from TIB (>IN)
        \ if char matches separator, BRANCH tibskiploop
        \ target tibcopyloop
            \ if no chars left in TIB, BRANCH exit
            \ consume next char from TIB (>IN)
            \ copy char to next PAD buffer
            \ inc PAD ptr
            \ inc COUNT  not a variable!!
            \ if char is separator, BRANCH exit
        BRANCH tibcopyloop
    \ target blk
        \ target blkskiploop
            \ if no chars left in BLK, branch exit
            \ consume next char from block
        \ if char matches separator, BRANCH blkskiploop
        \ target blkcopyloop
            \ if no chars left in block, BRANCH exit
            \ consume next char in block
            \ copy char to next PAD buffer
            \ inc PAD ptr
            \ inc COUNT  not a variable!!
            \ if char is separator, BRANCH exit
        BRANCH blkcopyloop
    \ target exit
    \ copy COUNT into first byte of PAD buffer  this is not a variable!!
    \ push address of PAD buffer on stack
    ;

===============================================================================

---- design: read/interpret "shell" loop (REPL)

: REPL
    \ nextline
    TIB TIBZ EXPECT                   \ read in a whole line up to CR
    SPAN 0BRANCH ( nextline) -        \ empty lines are ignored

    \ nextword
    BL WORD   ( a)                    \ get a word
    DUP C@    ( a #)                  \ get count at address, if zero, there was no word
    0= NOT 0BRANCH ( gotword) - ( a)
    DROP ( )
    ." Ok"                            \ TODO: not written this word yet (SHOWSTR DOSTR 2Ok)
    BRANCH ( nextline) -

    \ gotword ( a)
    \ TODO form the word into a string of correct format (addr and count? add 1 to addr?)
    \ TODO find address of word in dict, push addr on stack, 0 if not found
    \ if not found, show word and " Err", skip to end of line, nextline
    EXECUTE                            \ execute the word whose address info is on the DS
    BRANCH ( nextword) - ;


===============================================================================


add to word later: processing IN from a non keyboard stream
BLK is a flag and a pointer. If it is zero, then there is no block being loaded,
and WORD will scan the input stream. If it is non zero, then input will be scanned
from the block number indicated in BLK. This is how input redirection occurs.

WORD invokes BLOCK to guarantee that the block of interest is actually loaded
into a buffer.


================================================================================

NATIVES STILL REQUIRED
(number will be needed for a proper parser to work)

n_NUMBER  ( a -- d)                  using any base, convert string at a, to binary value. Is str count byte preceded??

DICT WRAPPERS FOR NATIVES
: NUMBER   ( a -- d)                 /P254 n_NUMBER  using (any) base, convert string at a, to binary value

\ : FLAGS  ( -- n)                     /ADD  n_RDPFA  CONST  Address of flags variable
\ : BINDEX   ( -- a)                   /ADD  n_RDPFA  VAR    array of block buffer index info (0=>not loaded)
\ : BB0   ( -- a)                      /ADD  n_RDPFA  CONST  Address of first byte of block buffers



--------------------------------------------------------------------------------

#TODO: Need to decide how to handle numbers
# (The test harness now exposes this problem)

# i.e. are they signed or unsigned. So is False -1 or 0xFFFF?
# what happens if you add 1 to 65535, it should wrap to 0
# so all the maths *might* need to be done with the Number() class to
# simulate a true 16 bit machine. Same for Double() and also need
# a Byte() if there are arithmetic ops for bytes. Might also want a
# Boolean() to simulate boolean behaviour with a S16, and a way to
# convert to unsigned for U< for example.

# Might just & 0xFFFF in all maths operations?

: ( xxx)   ( -- )                    /P26  n_DODOES Comment, terminated by )
: \                                  comment to end of line being parsed

: INTERPRET   ( -- )                 /P286 n_DODOES text interpret input stream until exhausted

===============================================================================

----- CONDITIONS
#### Need parser for branch targets
# probably some stacking here to allow nesting?
# think this is compile only?
: IF words ( ? -- )                    /P92  n_DODOES If non zero, executes xxx, otherwise yyy, continues with zzz
  ELSE words                           / use 0BRANCH to write this
  THEN ;

----- LOOPS
### Need parser for branch targets
# probably some stacking here to allow nesting?
: I ( -- n)                          /P207 n_RDPFA loop counter
: J ( -- n)                          /P207 n_RDPFA loop counter
: DO ... LOOP   DO:                  /P131 n_DODOES Finite loop
                  ( limit index -- )
                LOOP:  ( -- )
: DO ... +LOOP  DO:                  /P131 DODOES Finite stepped loop
                  ( limit index -- )
                +LOOP:  ( n -- )
: LEAVE   ( -- )                     /P131 DODOES Terminate at next LOOP
: BEGIN ... UNTIL   UNTIL: ( ? -- )  /P131 DODOES Indefinite loop exits when ? true
: BEGIN xxx WHILE yyy REPEAT   WHILE:  ( ? -- )   /P131 DODOES Indefinite loop always executes xxx


#### Gets hard from here downwards ********************************************
# Need to build up some more support in proper loops and proper conditions
# and possibly using a parser first,
to make all of this 'real algorithmic code' easier to bootstrap

Those that need loops could probably be bootstrapped using the BRANCH and 0BRANCH
with the various comparisons, and rewritten later when proper parsing and compiling
and IF/LOOP target resolution is working. Counted loops would help, although
could maintain the count on TOS for a naive initial implementation.





#### Needs input parser
: ASCII   ( -- c)                    /P161 n_DODOES Next input char into ascii equivalent

----- STRING PROCESSING
#### Needs loops
: -TRAILING   (a #1 -- a #2)         /P254 n_DODOES eliminates trailing blanks from string
: -TEXT   ( a1 # a2 -- ?)            /P254 n_DODOES compare strings
: -MATCH   ( d # s # -- a ?)         /P254 n_DODOES search for string
: CONVERT   ( ud1 a1 -- ud2 a2)      /P254 n_DODOES string to binary value

----- OUTPUT CONVERSION AND FORMATTING
#### Needs loops and conditions
: ?   ( a -- )                       /P190 n_DODOES prints contents of addr followed by 1 space
: .( text)   ( -- )                  /P77  n_DODOES Display text
: ." xxx"   ( -- )                   /P26  n_DODOES Displays the character string xxx. The " character terminates the string
: .   ( n -- )                       /P26  n_DODOES Display number followed by a space
: D.   ( d -- )                      /P161 n_DODOES print 32 bit number and 1 space
: U.   ( u -- )                      /P161 n_DODOES Print unsigned number and space
: <#                                 /P161 n_DODOES Begin number conversion
: #                                  /P161 n_DODOES Convert one digit into output char string
: #S                                 /P161 n_DODOES Convert until result is zero
: c HOLD                             /P161 n_DODOES Insert char
: n SIGN                             /P161 n_DODOES Insert minus sign
: #>                                 /P161 n_DODOES End conversion
: <# ... #>   ( d -- a u)            /P161 n_DODOES 32 bit unsigned
              ( u 0 -- a u)          /P161 n_DODOES 16 bit signed
: <# ... n SIGN #>   ( |d| -- a u)   /P161 n_DODOES 32 bit signed
                or   ( |d| 0 -- a u) /P161 n_DODOES 16 bit signed
: U.R   ( u width -- )               /P161 n_DODOES Print unsigned number right justified
: .R   ( n width -- )                /P131 n_DODOES Prints number right justified to width
: D.R   ( d width -- )               /P161 n_DODOES print 32 bit number right justified

----- MEMORY OPS
#### Needs loops
: BLANK   ( a # -- )                 /P254 n_DODOES fills with ascii 0
: MOVE   ( a1 a2 # -- )              /P254 n_DODOES copy region of memory
: CMOVE   ( a1 a2 # -- )             /P254 n_DODOES copy char region of memory
: CMOVE>   ( a1 a2 # -- )            /P254 n_DODOES copy char region of memory backwards
: FILL   ( a u b -- )                /P190 n_DODOES fills u bytes of memory
: ERASE   ( a u -- )                 /P190 n_DODOES zeros n bytes of memory
: DUMP   ( a u -- )                  /P190 n_DODOES display u bytes of memory

: >TYPE   ( a # -- )                 \ P254 n_DODOES output string moved to PAD before output
\ probably uses CMOVE??


----- DISK I/O

: BLOCK   ( u -- a)                  /P254 n_DODOES 1024 * BB0 + ;
: (LOADED) ( n b ? -- )              /ADD  n_DODOES  block buffer loaded or unloaded?


#### Needs loops
: TRIAD   ( n -- )                   /P77  n_DODOES Displays 3 blocks
: SHOW   ( lo hi -- )                /P77  n_DODOES Lists in triad form
: INDEX   ( lo hi -- )               /P77  n_DODOES Displays comment lines only
: LIST   ( n -- )                    /P77  n_DODOES Lists a disk block
: THRU   ( lo hi -- )                /P77  n_DODOES Loads all blocks inclusive
: BUFFER   ( u -- a)                 /P254 n_DODOES like block, not necc read from mass storage
: LOAD   ( n -- )                    /P77  n_DODOES Loads a disk block (compiles or executes) assume (LOAD)
: FLUSH   ( -- )                     /P77  n_DODOES Writes all updated disk buffers to disk, and unassigns
: LOCATE xxx   ( -- )                /P77  n_DODOES Lists block from which xxx has been loaded
: VIEW xxx   ( -- )                  /P77  n_DODOES Lists block from which xxx has been loaded
: UPDATE   ( -- )                    /P254 n_DODOES Most recently referenced block marked modified
: SAVE-BUFFERS   ( -- )              /P254 n_DODOES Writes all updated buffers, un-updated, still assigned
: FLUSH   ( -- )                     /P254 n_DODOES saves then unassigns all buffers
: EMPTY-BUFFERS   ( -- )             /P254 n_DODOES marks all buffers empty without saving

----- EXECUTING

: QUIT   ( -- )                      /P221 n_DODOES clear RS, back to monitor
: (EXECUTE)   ( a -- )               /ADD  n_DODOES execute from address (IP !)
: @EXECUTE   ( a -- )                /P221 n_DODOES executes dict entry pfa pointed to by contents of a, nothing if zero
: ABORT" xxx"   ( ? -- )             /P92  n_DODOES If flag true, shows last word and text, clears user stacks, back to terminal.

----- CREATIONAL
: CONSTANT xxx   ( n -- )            /P190 n_DODOES create constant with a value
           xxx:  ( -- n)
: VARIABLE xxx   ( -- )              /P190 n_DODOES create variable (returns addr when exec)
           xxx: ( -- a)
: 2VARIABLE xxx   ( -- )             /P190 n_DODOES create double length var, addr when exec
            xxx:  ( -- a)
: 2CONSTANT xxx   ( d -- )           /P190 n_DODOES create double length const with value
            xxx:  ( -- d)

----- COMPILATION
: HERE   ( -- a)                     /P221 n_RDPFA Next available dictionary location (H @)
: RECURSE ( -- )                     /P211 n_DODOES compile address of the word being defined, to allow recursion
: CONTEXT   ( -- a)                  /P221 n_DODOES address of var that specifies dict search order
: CURRENT   ( -- a)                  /P221 n_DODOES addr of var specifying the vocab for new defns
: STATE   ( -- a)                    /P286 ADRVAR true if compiling, false if interpreting
: >BODY   ( cfa -- pfa)              /P221 n_DODOES pfa address of cfa address
: LIT" xxx"   run-time: ( -- a)      /P254 n_DODOES compiles literal (used in definitions)
: LITERAL   compile-time: ( n -- )   /P286 n_DODOES compiles a value
            run-time: ( -- n)
: [']   compile-time: ( -- )         /P221 n_DODOES compiles address of next word in defn as a literal
        run-time: ( -- a)
: [   ( -- )                         /P286 n_DODOES leaves compile mode
: ]   ( -- )                         /P286 n_DODOES enters compile mode
: COMPILE xxx   ( -- )               /P286 n_DODOES compile a word
: [COMPILE] xxx   ( -- )             /P286 n_DODOES immediate word gets compiled
: FORGET name   ( -- )               /P77  n_DODOES Removes all dict entries up to and including this one
: ALLOT   ( n -- )                   /P190 n_DODOES adds n bytes to parameter field of most recently defined word
: ,   ( n -- )                       /P190 n_DODOES compiles n into next available cell in dict
: C,   ( b -- )                      /P190 n_DODOES compiles b into next available byte in dict
: STRING   ( c -- )                  /P254 n_DODOES compiles string literal into dict as counted string
: IMMEDIATE   ( -- )                 /P286 n_DODOES marks recently defined word by setting immediate bit
: DOES>   run-time: ( -- a)          /P286 n_DODOES creates defining word, end of compile-time begin of run-time
: CREATE xxx   ( -- )                /P190 n_DODOES create dictionary header, (xxx returns addr when exec)
         xxx:  ( -- a)
: ; ( -- )                           /ADD  n_DODOES end of definition (compile exit, so ' EXIT)
: ' xxx   ( -- a)                    /P221 n_DODOES find dict address of xxx

----- ALU/DOUBLES
: C?   ( -- ?)                       /ADD  n_DODOES query C flag in FLAGS var
: V?   ( -- ?)                       /ADD  n_DODOES query V flag in FLAGS var
: Z?   ( -- ?)                       /ADD  n_DODOES query Z flag in FLAGS var
: P?   ( -- ?)                       /ADD  n_DODOES query P flag in FLAGS var
: 0.  ( -- 0 0)                      0 0 ;
: D+   ( d1 d2 -- dsum)              /P161 n_DODOES adds 32 bit (synth if carry?)
: D-   ( d1 d2 -- d-diff)            /P161 n_DODOES subtracts 32 bit (synth if carry?)
: D0=   ( d -- ?)                    /P161 n_DODOES true if zero
: D=   ( d1 d2 -- ?)                 /P161 n_DODOES equality check
: D<   ( d1 d2 -- ?)                 /P161 n_DODOES true if less
: DU<   (ud1 ud2 -- ?)               /P161 n_DODOES true if unsigned less
: DNEGATE   ( d -- -d)               /P161 n_DODOES negates 32 bit
: DABS   ( d -- |d|)                 /P161 n_DODOES absolute of 32 bit
: DMAX   ( d1 d2 -- d-max)           /P161 n_DODOES max of 32 bit
: DMIN   ( d1 d2 -- d-min)           /P161 n_DODOES min of 32 bit

----- NATIVES: ALU/multiply/divide
: */   ( n1 n2 n3 -- result)         /P113 n_DODOES Multply then divide, 32bit intermediate
: */MOD   ( n1 n2 n3 -- n-rem n-result)   /P113 n_DODOES Multiply then divide, double length intermediate
: UM*   ( u1 u2 -- ud)               /P161 n_DODOES multiply 16 bit, 32 bit result
: UM/MOD   ( ud u1 -- u2 u3)         /P161 n_DODOES divide mod 16 bit, 32 bit result
: M*   ( n1 n2 -- d-prod)            /P161 n_DODOES multiply 16 bit, 32 bit result
: M+   ( d n -- d-sum)               /P161 n_DODOES 32bit add to 16 bit 32 bit result
: M/   ( d n -- n-quot)              /P161 n_DODOES 32bit divide 16 bit, 32 bit result
: M*/   ( d n u -- d)                /P161 n_DODOES mult 32 bit number by 16 bit, 32 bit result

----- VOCAB
: FORTH   ( -- )                     /P221 n_DODOES Make forth context vocab
: EDITOR   ( -- )                    /P221 n_DODOES Make editor the context vocab
: ASSEMBLER   ( -- )                 /P221 n_DODOES Make assembler the context vocab
: DEFINITIONS   ( -- )               /P221 n_DODOES sets current vocab to context vocab








------ DODOES -----------------------------------------------------------------

- read the DODOES in brad rodrigez "moving forth ch 3"
  basically DODOES arranges for the IP to be the PFA following, and then does NEXT
  to start executing high level code from there.
  so DOES> puts the address of DODOES in the next defined cell, and then
  the following high level actions are compiled after it.
  ; compiles in an EXIT (basically a high level return)

DOES> is executed during Sequence 1, when CONSTANT is compiled. Thus DOES> is a Forth IMMEDIATE word. It does two things:

a. It compiles the Forth word (DOES>) into CONSTANT.
b. It compiles a JSR DODOES into CONSTANT.

Because DOES> is marked as immediate, when used in a definition, instead of being copied into the definition,
it actually executes (and then puts the DOES> and JSR DODOES)

So, any non immediate words are copied into the PFA, any immediate words are executed.
Those immediate words run code at compile time, rather than deferring the code to runtime.


-------------------------------------------------------------------------------

- investigate and write/test creational words, so we can seed the dictionary

: n_CREATE   ( -- )                 { } ;     / root of all creation words, creates a new dict entry
: n_DOCOL   ( -- )                  { } ;     / colon definition, define a new high level word
: n_DOCON   ( -- )                  { } ;     / create a new constant value
: n_DOVAR   ( -- )                  { } ;     / create a new uservar in usertable


- seed the dictionary with definitions for system constants
: SV0   ( -- a)                      /ADD  CODE 'n_RDPFA' Address of start of system vars
: D0   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of bottom of dictionary
: H    ( -- a)                       /P213 CODE 'n_RDPFA' Address of variable holding next free dict addr
: S0   ( -- a)                       /P221 CODE 'n_RDPFA' Address of bottom of data stack
: SP   ( -- a)                       /P215 CODE 'n_RDPFA' Address of data stack pointer var
: R0   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of bottom of return stack
: RP   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of return stack pointer var
: IP   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of instruction pointer var
: 0   ( -- 0)                        /P190 CODE 'n_RDPFA' const zero
: 1   ( -- 1)                        /P190 CODE 'n_RDPFA' const 1

- seed the dictionary with definitions for system variables
: BB0   ( -- a)                      /ADD CODE 'n_RDPFA' Lowest address of start of 1K block buffers
: BBN   ( -- #)                      /ADD CODE 'n_RDPFA' Number of 1K block buffers

- seed the dictionary with definitions for user variables
(eventually, add BASE, but not yet)

- seed the dictionary with definitions for nucleus words
: !   ( n a -- )                     /P190 CODE 'n_STORE'  store single number into addr
: @   ( a -- n)                      /P190 CODE 'n_FETCH'  replace addr with contents
: C!   ( b a -- )                    /P190 CODE 'n_STORE8' store 8 bit value
: C@   ( a -- b)                     /P190 CODE 'n_FETCH8' fetch 8 bit value
: KEY?  ( -- ?)                      /ADD  CODE 'n_KEYN' Check if a key is waiting
: KEY   ( -- c)                      /P254 CODE 'n_KEY'  Get next char from input
: EMIT   ( c -- )                    /P26  CODE 'n_EMIT' Send character to output
: SWAP   ( n1 n2 -- n2 n1)           /P49  CODE 'n_SWAP' Reverse top two stack items
: DUP   ( n -- n n)                  /P49  CODE 'n_DUP'  Duplicate top stack item
: OVER   ( n1 n2 -- n1 n2 n1)        /P49  CODE 'n_OVER' Make a copy of second item and puts on top
: ROT   ( n1 n2 n3 -- n2 n3 n1)      /P49  CODE 'n_ROT'  Rotate 3rd item to top
: DROP   ( n -- )                    /P49  CODE 'n_DROP' Discard top item
: +   ( n1 n2 -- n-sum)              /P49  CODE 'n_ADD'    Add
: -   ( n1 n2 -- n-diff)             /P49  CODE 'n_SUB'    Subtract (n1 - n2)
: AND   ( n1 n2 -- n-and)            /P92  CODE 'n_AND'    Logical AND
: OR   ( n1 n2 -- n-or)              /P92  CODE 'n_OR'     Logical OR
: XOR   ( n1 n2 -- n-xor)            /P92  CODE 'n_XOR'    Logical XOR
: *   ( n1 n2 -- n-prod)             /P49  CODE 'n_MULT'   Multiply
: /   ( n1 n2 -- n-quot)             /P49  CODE 'n_DIV'    Divide (n1/n2)
: MOD   ( n1 n2 -- n-rem)            /P49  CODE 'n_MOD'    Remainder from division (n1/n2)
: FLAGS  ( -- a)                     /ADD  CODE 'n_RDPFA'  Address of var of flags from last saved ALU operation
: FLAGS>   ( -- )                    /ADD  CODE 'n_FLAGS'  Save last ALU C,V,Z,P flags to FLAGS
: BRANCH                             /ADD CODE 'n_BRANCH'  branch using relative offset following
: 0BRANCH                            /ADD CODE 'n_BRANCH0' branch if TOS=0, using relative offset following
: RBLK  ( n a -- )                   /ADD CODE 'n_RBLK'    Load 1K disk block n into memory at addr (see MMSForth)
: WBLK  ( n a -- )                   /ADD CODE 'n_WBLK'    Save 1K memory from addr to disk block n (see MMSForth)


===== CORE DATA STRUCTURES ====================================================



----- DICTIONARY --------------------------------------------------------------

dictionary has
  header(name, link)
  body(code, param)

NFA - Name field address (name)
LFA - link field address (link) points to NFA of previous entry (holds 0 at end)
CFA - code field address (code)
PFA - parameter field address (parameters)

CFA (CODE) is address of assembly routine
PFA (PARAMETERS) are parameters to the routine
(i.e. parameters always follow the code address, rather than being pushed on stack)
code field is class method (action), parameters are instance variables
(so it's object oriented)


All of the "hard work" of a defining word is done by a kernel word, CREATE, which parses a
name from the input stream, builds the header and Code Field for a new word, and links it into the
dictionary. (In fig-Forth this word is called <BUILDS.)


----- USER VARIABLE TABLE ----------------------------------------------------------

For tasking (multi programming), each user task needs its own user variable table,
and variables must be stored as offsets into this table rather than absolute addresses.
That way, each task can have it's own instance of a user variable.

System variables are shared between all tasks, as is the dictionary.

Not sure yet what happens about parameter stack and return stack, block buffers, pad, tib,
need to look into various multi-programmed forth designs first to see how that works.

USER VARIABLES - see BRODIE P 218 (to do with multi tasking)
  DICT entry points to VARIABLE CODE
  PFA contains offset into USER TABLE
  USER TABLE stores actual value.

  This means that the baseaddr of the USER TABLE can be changed
  between each USER (TASK), the dict is shared, but the user table
  is unique for each user/task. e.g. BASE is defined in the USER TABLE.
  Not defined using VARIABLE (ordinary variable).
  (This will be useful for multi-instanced pyforth objects that share the
  same memory image and runtime for expediency)

  Q? So how are these defined?


===== MACHINE CODE ============================================================

CFA is always the address of a machine code routine to call when executing a word.

For a machine code word
  put addr of PFA in CFA
  store machine code in PFA
  ending with JMP EXIT

For a high level routine:
  put addr of DODOES in CFA
  list of CFA word addresses in PFA
  end with CFA(EXIT)

: DODOES ( machine code)
  Push PFA onto DS?
  Pop CPU stack to get address of high level action routine (this is the PFA)
  Save old IP on RS
  load address of high level thread (PFA) into IP
  NEXT to continue interpretation at IP


DOES> and (DOES>)

: CONSTANT ( n -- )
    CREATE      \ create the new word
    ,           \ append the TOS value to the dictionary,
                \   as the 1st cell of the Parameter Field
    DOES>       \ end "create" part & start "action" part
    @           \ given the PFA, fetch its contents
    ;

(everything from : to DOES> is executed when CONSTANT is executed, and it builds the parameter
field of the defined word.

Everything from DOES> to ; is high level code that is executed when children of CONSTANT
get executed, i.e. the high level fragment that it's CFA will point to.

i.e. the create part, and the action part.
The create part is run at creation time.
The action part is run at runtime of the created word.


DOES> is executed when CONSTANT is compiled. Thus DOES> is a Forth IMMEDIATE word. It does two things:

a. It compiles the Forth word (DOES>) into CONSTANT.
b. It compiles a JSR DODOES into CONSTANT.

Note that DOES> leaves the Forth compiler running, in order to compile the high-level fragment which follows.
Also, even though JSR DODOES is not itself Forth code, an IMMEDIATE word such as DOES> can cause it to be compiled
in the middle of Forth code.


(DOES>) is part of the word CONSTANT, so it executes when CONSTANT executes. It does the following:

a. It gets the address of the machine code that immediately follows (JSR DODOES), by popping IP from the
Forth Return Stack.

b. It puts that address into the Code Field of the word just defined by CREATE.

c. It performs the action of EXIT, causing CONSTANT to terminate here and not attempt to execute the fragment
that follows.

NFA:   8,CONSTANT
LFA:   prev
CFA:   addr(DOCOL)
PFA:   <-- create part -->
       CFAof CREATE
       CFAof ,
       CFAof (DOES>)
       <-- "DOCON" action routine -->
       CFA: JSR DODOES
       PFA: CFAof @
            CFAof EXIT

3 parts of the defining lifecycle
sequence 1: CONSTANT is being defined
sequence 2: CONSTANT is being executed
sequence 3: constant-type word is being executed

Address of a word is the address of it's CFA
tick returns PFA

branching words as compiled into PFA are followed by a branch offset???

LOOP is an immediate word that compiles in a (LOOP)
." is an immediate word that compiles in (.")


----- NATIVE CALLS ------------------------------------------------------------

read CFA number means load from that address
at that address in low memory (e.g. 2) could be a FF 02 e.g.(TRAP 02)
causes python to index into a list of functions
2 in the list is ("DOCON", docon)
when building that dict entry at nucleus boot,
search for "DOCON" and store 2 in the DICT to complete the circle.
When the docon() returns, it returns to the python loop that is driving
the forth, so it will all just tick away nicely.

The native words are then just defined as normal functions with a simple
dispatch table and dispatcher function in the CFA handler. Then all we
have to do is work out the minimum number of native functions required
to allow all other functions to be synthesisable as high level code
for an initial quick port.

Porting to a new language then becomes
- translate the forth.py into the new target language
- including translating the native functions into new target language
- including knitting up in/out/disk to target IO
- run it, and it should self boot.

Other languages to try ports for: java, C, php, lua, javascript
php and javascript are interesting because it allows use in web context
including server side and browser side.

Could then write an in-browser forth system that could be used by people
learning the language, and for experimentation. Python is then the first
port and the initial specification validation language.

If want to later write a 6502 simulator or any processor simulator, could
still do it, it could be extended to that.


===== INTERFACE SPEC ==========================================================

PLAN:
1. define everything in forth, ignoring dependencies
2. make sure sorting is correct for good boot order
3. spot bad dependencies with a dependency tool (def some to break dependencies)
   This is just like the dependency sorter in the excel2php converter we wrote.
4. write native implementations to break bad dependencies
5. write boot code in python to get nano kernel booted into memory


----- NANO KERNEL ---------------------------------------------------------------------

This is a non optimal list, but a good first stab at a minimal kernel
that is required to build up the next layers.

The whole point is to define as little as possible natively to allow fast porting,
and then optimise later when on a real platform and have an appropriate assembler
written, to replace synthesised versions with platform specific assembled versions.


----- NATIVE ROUTINE INTERFACE SPEC -------------------------------------------

(39 in list, 78 bytes of MEM at start for vectors if use vectors?)
Only need to use vectors if might want to insert a CPU simulator later.
If don't want that, just 'running native' a number stored at CFA will do it.
Could be a build option to save a level of indirection if no CPU simulator
required. i.e. does CFA store address of machine code, or machine code instruction
(direct, indirect, subroutine option)

NOP       (does nothing)
--- memory read/write
STORE     (store 16bit at address)
FETCH     (read 16 bit from address)
STORE8    (store 8 bit at address)
FETCH8    (read 8 bit from address)
--- I/O
KEY?      (checks number of keys waiting in input stream)
KEY       (removes next key from input stream)
EMIT      (writes one byte to output stream)
--- ALU
ADD       (add top two stack items, if exists)
SUB       (subract top two stack items, if exists)
AND       (bit-and top two stack items, if exists)
OR        (bit-or top two stack items, if exists)
XOR       (bit-xor top two stack items, if exists)
MULT      (16 bit multiply top two stack items, if exists)
DIV       (16 bit divide top two stack items, if exists)
MOD       (remainder from 16 bit divide top two stack items, if exists)
FLAGS     (update FLAGS variable from last operation)
--- branching
BRANCH    (unconditional branch based on relative stored in next IP)
BRANCH0   (branch only if tos=0 based on relative stored in next IP)
--- data stack access
SWAP      (swap top two items on stack if exists)
DUP       (copy top item to top of DS if exists)
OVER      (copy 2nd item to top of DS if exists)
ROT       (rotate 3 items on top of DS if exists)
DROP      (remove top of DS if exists)
--- disk block access
RBLK      (read a disk block)
WBLK      (write a disk block)

--- variable table access
RDPFA     (read constant out from PFA and push to DS)
RDPFAREL  (read constant from PFA, add onto user variable table base, push address to DS)
--- executional words
NEXT      (run next high level addr pointed to by IP)
DODOES    (PFA containing high level thread of CFA addresses, sometimes called ENTER, runs high level forth code)
EXIT      (pops IP from return stack and jumps to NEXT)
EXECUTE   (??? high level? does this do anything extra to above?)
LIT       (put LIT in next IP address on TOS) - is this a native routine or a high level routine?
--- creational words
CREATE    (??root of all creation words)
DOCOL     (colon definition, define a new high level word)
DOCON     (??constant value)
DOVAR     (??storage for a var)
DOVOC     (something to do with vocabulary change? could be synthesised?)
DOLIT     (compile a literal at H)


----- MANUALLY BOOTED DICT SPEC -----------------------------------------------

These instructions will be hand-generated into the dictionary by the platform language

-------- initial constants and variables
: SV0   ( -- a)                      /ADD  CODE 'n_RDPFA' Address of start of system vars
: D0   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of bottom of dictionary
: H    ( -- a)                       /P213 CODE 'n_RDPFA' Address of variable holding next free dict addr
: S0   ( -- a)                       /P221 CODE 'n_RDPFA' Address of bottom of data stack
: SP   ( -- a)                       /P215 CODE 'n_RDPFA' Address of data stack pointer var
: R0   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of bottom of return stack
: RP   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of return stack pointer var
: IP   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of instruction pointer var
: 0   ( -- 0)                        /P190 CODE 'n_RDPFA' const zero
: 1   ( -- 1)                        /P190 CODE 'n_RDPFA' const 1

----- store and fetch
: !   ( n a -- )                     /P190 CODE 'n_STORE'  store single number into addr
: @   ( a -- n)                      /P190 CODE 'n_FETCH'  replace addr with contents
: C!   ( b a -- )                    /P190 CODE 'n_STORE8' store 8 bit value
: C@   ( a -- b)                     /P190 CODE 'n_FETCH8' fetch 8 bit value

-------- Simple IO
: KEY?  ( -- ?)                      /ADD  CODE 'n_KEYN' Check if a key is waiting
: KEY   ( -- c)                      /P254 CODE 'n_KEY'  Get next char from input
: EMIT   ( c -- )                    /P26  CODE 'n_EMIT' Send character to output

-------- Data stack
: SWAP   ( n1 n2 -- n2 n1)           /P49  CODE 'n_SWAP' Reverse top two stack items
: DUP   ( n -- n n)                  /P49  CODE 'n_DUP'  Duplicate top stack item
: OVER   ( n1 n2 -- n1 n2 n1)        /P49  CODE 'n_OVER' Make a copy of second item and puts on top
: ROT   ( n1 n2 n3 -- n2 n3 n1)      /P49  CODE 'n_ROT'  Rotate 3rd item to top
: DROP   ( n -- )                    /P49  CODE 'n_DROP' Discard top item

-------- ALU
: +   ( n1 n2 -- n-sum)              /P49  CODE 'n_ADD'    Add
: -   ( n1 n2 -- n-diff)             /P49  CODE 'n_SUB'    Subtract (n1 - n2)
: AND   ( n1 n2 -- n-and)            /P92  CODE 'n_AND'    Logical AND
: OR   ( n1 n2 -- n-or)              /P92  CODE 'n_OR'     Logical OR
: XOR   ( n1 n2 -- n-xor)            /P92  CODE 'n_XOR'    Logical XOR
: *   ( n1 n2 -- n-prod)             /P49  CODE 'n_MULT'   Multiply
: /   ( n1 n2 -- n-quot)             /P49  CODE 'n_DIV'    Divide (n1/n2)
: MOD   ( n1 n2 -- n-rem)            /P49  CODE 'n_MOD'    Remainder from division (n1/n2)
: FLAGS  ( -- a)                     /ADD  CODE 'n_RDPFA'  Address of var of flags from last saved ALU operation
: FLAGS>   ( -- )                    /ADD  CODE 'n_FLAGS'  Save last ALU C,V,Z,P flags to FLAGS

----- low level branching
: BRANCH                             /ADD CODE 'n_BRANCH'  branch using relative offset following
: 0BRANCH                            /ADD CODE 'n_BRANCH0' branch if TOS=0, using relative offset following

-------- disk blocks
: BB0   ( -- a)                      /ADD CODE 'n_RDPFA' Lowest address of start of 1K block buffers
: BBN   ( -- #)                      /ADD CODE 'n_RDPFA' Number of 1K block buffers
: RBLK  ( n a -- )                   /ADD CODE 'n_RBLK'    Load 1K disk block n into memory at addr (see MMSForth)
: WBLK  ( n a -- )                   /ADD CODE 'n_WBLK'    Save 1K memory from addr to disk block n (see MMSForth)

----- running words
: DODOES                             /ADD CODE 'n_DODOES'
: NEXT                               /ADD CODE 'n_NEXT'
: ENTER                              /ADD CODE 'n_ENTER'
: EXECUTE                            /ADD CODE 'n_EXECUTE'

-- defining words
(note some of these are listed in 'synthesisable region too, need to resolve this)
: CREATE                             /??? CODE 'n_CREATE'
: :                                  /ADD CODE 'n_DOCOL'
: CONSTANT                           /ADD CODE 'n_DOCON'
: VARIABLE                           /ADD CODE 'n_DOVAR'
: LIT                                /ADD CODE 'n_DOLIT'


----- SYNTHESISABLE WORDS INTERFACE SPEC --------------------------------------

#### HERE ####

The rest of the words will be defined in terms of other words (high level forth words
that are synthesised). They may be replaced by native versions later to improve performance
once an initial language port is completed)

: HERE   ( -- a)                     /P213 n_DODOES  put value of H (next free dict addr) onto TOS
: UV0   ( -- a)                      /ADD  n_RDPFA   Address of start of user vars
: FALSE   ( -- 0)                    /P190 n_RDPFA   false (0)    : FALSE 0 ;
: TRUE   ( -- -1)                    /P190 n_RDPFA   true (-1)    : TRUE 0 1 - ;
: 2   ( -- 2)                        /ADD  n_RDPFA   const 2 (for simple shifts/multiplies) : 2 1 1 + ;
: (EXECUTE)   ( a -- )               /ADD  n_DODOES  execute from address (IP !)

/ might be synthesisable with new FLAGS feature
: */MOD   ( n1 n2 n3 -- n-rem n-result)   /P113 n_DODOES Multiply then divide, double length intermediate
: UM*   ( u1 u2 -- ud)               /P161 n_DODOES multiply 16 bit, 32 bit result
: UM/MOD   ( ud u1 -- u2 u3)         /P161 n_DODOES divide mod 16 bit, 32 bit result
: M*   ( n1 n2 -- d-prod)            /P161 n_DODOES multiply 16 bit, 32 bit result
: M+   ( d n -- d-sum)               /P161 n_DODOES 32bit add to 16 bit 32 bit result
: M/   ( d n -- n-quot)              /P161 n_DODOES 32bit divide 16 bit, 32 bit result
: M*/   ( d n u -- d)                /P161 n_DODOES mult 32 bit number by 16 bit, 32 bit result
: >R   ( n -- )                      /P113 n_DODOES Move data stack to return stack          : >R RP @ 1 + DUP ROT ! RP ! ;
: R>   ( -- n)                       /P113 n_DODOES Move return stack to data stack          : R> RP DUP @ @ SWAP 1 - RP ! ;
: R@   ( -- n)                       /P113 n_DODOES Copies top of return stack to data stack : R@ RP @ @ ;
: C?   ( -- ?)                       /ADD  n_DODOES query C flag in FLAGS var
: V?   ( -- ?)                       /ADD  n_DODOES query V flag in FLAGS var
: Z?   ( -- ?)                       /ADD  n_DODOES query Z flag in FLAGS var
: P?   ( -- ?)                       /ADD  n_DODOES query P flag in FLAGS var
: \ ( -- )                           /???  n_DODOES comment until next CR
: SP@   ( -- a)                      /P221 n_RDPFA (sp-fetch) Address of top data stack item)
: HERE   ( -- a)                     /P221 n_RDPFA Next available dictionary location (H @)
: IP ( -- n )                        /P204 n_RDPFA interpreter pointer
: I ( -- n)                          /P207 n_RDPFA loop counter
: J ( -- n)                          /P207 n_RDPFA loop counter
: 0.  ( -- 0 0)                      /P190 n_RDPFA  double length const 0 (0 0)
: D+   ( d1 d2 -- dsum)              /P161 n_DODOES adds 32 bit (synth if carry?)
: D-   ( d1 d2 -- d-diff)            /P161 n_DODOES subtracts 32 bit (synth if carry?)
: BINDEX ( -- a)                     /ADD  ADRVAR array of block buffer index info (0 not loaded)
: BLK   ( -- a)                      /P254 ADRVAR number of storage block being interpreted as input stream (0 means IN)
: (LOADED) ( n b ? -- )              /ADD  n_DODOES block buffer loaded or unloaded
: EXIT   ( -- )                      /P221 n_DODOES removes return addr from RS, return to it (or terminate defn)
: STATE   ( -- a)                    /P286 ADRVAR true if compiling, false if interpreting
: ?DUP   ( n -- n n) or ( 0 -- 0)    /P92  n_DODOES Duplicates only if n is nonzero
: BLANK   ( a # -- )                 /P254 n_DODOES fills with ascii 0
: MOVE   ( a1 a2 # -- )              /P254 n_DODOES copy region of memory
: CMOVE   ( a1 a2 # -- )             /P254 n_DODOES copy char region of memory
: CMOVE>   ( a1 a2 # -- )            /P254 n_DODOES copy char region of memory backwards
: FILL   ( a u b -- )                /P190 n_DODOES fills u bytes of memory
: ERASE   ( a u -- )                 /P190 n_DODOES zeros n bytes of memory
: DUMP   ( a u -- )                  /P190 n_DODOES display u bytes of memory
: HEX   ( -- )                       /P161 n_DODOES Base 16
: OCTAL   ( -- )                     /P161 n_DODOES Base 8
: DECIMAL   ( -- )                   /P161 n_DODOES Base 10
: TRIAD   ( n -- )                   /P77  n_DODOES Displays 3 blocks
: SHOW   ( lo hi -- )                /P77  n_DODOES Lists in triad form
: INDEX   ( lo hi -- )               /P77  n_DODOES Displays comment lines only
: COUNT   ( a -- a+1 #)              /P254 n_DODOES convert counted string into TYPE expected format
: CR   ( -- )                        /P26  n_DODOES Output a carriage return/line feed
: SPACES   ( n -- )                  /P26  n_DODOES Blank spaces
: SPACE   ( -- )                     /P26  n_DODOES One space
: FORGET name   ( -- )               /P77  n_DODOES Removes all dict entries up to and including this one
: 1+   ( n -- n+1)                   /P113 n_DODOES Add one
: 1-   ( n -- n-1)                   /P113 n_DODOES Subtract one
: 2+   ( n -- n+2)                   /P113 n_DODOES Add two
: 2-   ( n -- n-2)                   /P113 n_DODOES Subtract two
: 2*   ( n -- n*2)                   /P113 n_DODOES Multiply by two
: 2/   ( n -- n/2)                   /P113 n_DODOES Divide by two
: ABS   ( n -- |n|)                  /P113 n_DODOES Absolute value
: NEGATE   ( n -- -n)                /P113 n_DODOES Change the sign
: MIN   ( n1 n2 -- min)              /P113 n_DODOES Minimum
: MAX   ( n1 n2 -- max)              /P113 n_DODOES Maximum
: <#                                 /P161 n_DODOES Begin number conversion
: #                                  /P161 n_DODOES Convert one digit into output char string
: #S                                 /P161 n_DODOES Convert until result is zero
: c HOLD                             /P161 n_DODOES Insert char
: n SIGN                             /P161 n_DODOES Insert minus sign
: #>                                 /P161 n_DODOES End conversion
: <# ... #>   ( d -- a u)            /P161 n_DODOES 32 bit unsigned
              ( u 0 -- a u)          /P161 n_DODOES 16 bit signed
: <# ... n SIGN #>   ( |d| -- a u)   /P161 n_DODOES 32 bit signed
                or   ( |d| 0 -- a u) /P161 n_DODOES 16 bit signed
: CONSTANT xxx   ( n -- )            /P190 n_DODOES create constant with a value
           xxx:  ( -- n)
: VARIABLE xxx   ( -- )              /P190 n_DODOES create variable (returns addr when exec)
           xxx: ( -- a)
: 2VARIABLE xxx   ( -- )             /P190 n_DODOES create double length var, addr when exec
            xxx:  ( -- a)
: 2CONSTANT xxx   ( d -- )           /P190 n_DODOES create double length const with value
            xxx:  ( -- d)
: PAGE   ( -- )                      /P131 n_DODOES Clears display and resets to left top
: RECURSE ( -- )                     /P211 n_DODOES compile address of the word being defined, to allow recursion
: CONTEXT   ( -- a)                  /P221 n_DODOES address of var that specifies dict search order
: CURRENT   ( -- a)                  /P221 n_DODOES addr of var specifying the vocab for new defns
: FORTH   ( -- )                     /P221 n_DODOES Make forth context vocab
: EDITOR   ( -- )                    /P221 n_DODOES Make editor the context vocab
: ASSEMBLER   ( -- )                 /P221 n_DODOES Make assembler the context vocab
: DEFINITIONS   ( -- )               /P221 n_DODOES sets current vocab to context vocab
: ." xxx"   ( -- )                   /P26  n_DODOES Displays the character string xxx. The " character terminates the string
: .   ( n -- )                       /P26  n_DODOES Display number followed by a space
: ( xxx)   ( -- )                    /P26  n_DODOES Comment, terminated by )
: LIST   ( n -- )                    /P77  n_DODOES Lists a disk block
: .( text)   ( -- )                  /P77  n_DODOES Display text
: THRU   ( lo hi -- )                /P77  n_DODOES Loads all blocks inclusive
: ABORT" xxx"   ( ? -- )             /P92  n_DODOES If flag true, shows last word and text, clears user stacks, back to terminal.
: BLOCK   ( u -- a)                  /P254 n_DODOES Address of first byte in block
: BUFFER   ( u -- a)                 /P254 n_DODOES like block, not necc read from mass storage
: TYPE   ( a # -- )                  /P254 n_DODOES transmits # chars starting at addr
: -TRAILING   (a #1 -- a #2)         /P254 n_DODOES eliminates trailing blanks from string
: PAD   ( -- a)                      /P221 ADRVAR addr of scratch area start
: >TYPE   ( a # -- )                 /P254 n_DODOES output string moved to PAD before output
: -TEXT   ( a1 # a2 -- ?)            /P254 n_DODOES compare strings
: -MATCH   ( d # s # -- a ?)         /P254 n_DODOES search for string
: TIB   ( -- a)                      /P221 ADRVAR Address of start of text input buffer
: >IN   ( -- a)                      /P254 ADRVAR present char offset in input stream
: EXPECT   ( a # -- )                /P254 n_DODOES wait for chars or newline
: SPAN   ( -- a)                     /P254 ADRVAR number of chars read in expect
: IMMEDIATE   ( -- )                 /P286 n_DODOES marks recently defined word by setting immediate bit
: INTERPRET   ( -- )                 /P286 n_DODOES text interpret input stream until exhausted
: >BODY   ( cfa -- pfa)              /P221 n_DODOES pfa address of cfa address
: @EXECUTE   ( a -- )                /P221 n_DODOES executes dict entry pfa pointed to by contents of a, nothing if zero
: STRING   ( c -- )                  /P254 n_DODOES compiles string literal into dict as counted string
: NOT   (? -- -?)                    /P92  n_DODOES Reverse sense of flag
: =   ( n1 n2 -- ?)                  /P92  n_DODOES True if n1 and n2 are equal
: <>   ( n1 n2 -- ?)                 /P92  n_DODOES True if n1 and n2 are not equal
: <   ( n1 n2 -- ?)                  /P92  n_DODOES True if ni less than n2
: U<   ( u1 u2 -- ?)                 /P161 n_DODOES Unsigned compare (use sub)
: >   ( n1 n2 -- ?)                  /P92  n_DODOES True if n1 greater than n2
: 0=   ( n -- ?)                     /P92  n_DODOES True if n is zero
: 0<   ( n -- ?)                     /P92  n_DODOES True if n is negative
: 0>   ( n -- ?)                     /P92  n_DODOES True if n is positive
: D0=   ( d -- ?)                    /P161 n_DODOES true if zero
: D=   ( d1 d2 -- ?)                 /P161 n_DODOES equality check
: D<   ( d1 d2 -- ?)                 /P161 n_DODOES true if less
: DU<   (ud1 ud2 -- ?)               /P161 n_DODOES true if unsigned less
: DNEGATE   ( d -- -d)               /P161 n_DODOES negates 32 bit
: DABS   ( d -- |d|)                 /P161 n_DODOES absolute of 32 bit
: DMAX   ( d1 d2 -- d-max)           /P161 n_DODOES max of 32 bit
: DMIN   ( d1 d2 -- d-min)           /P161 n_DODOES min of 32 bit
: ALLOT   ( n -- )                   /P190 n_DODOES adds n bytes to parameter field of most recently defined word
: ,   ( n -- )                       /P190 n_DODOES compiles n into next available cell in dict
: C,   ( b -- )                      /P190 n_DODOES compiles b into next available byte in dict
: +!   ( n a -- )                    /P190 n_DODOES add single len number to contents of addr
: 2!   ( d a -- )                    /P190 n_DODOES store double length number
: 2@   ( a -- d)                     /P190 n_DODOES return double length contents
: U.R   ( u width -- )               /P161 n_DODOES Print unsigned number right justified
: .R   ( n width -- )                /P131 n_DODOES Prints number right justified to width
: D.R   ( d width -- )               /P161 n_DODOES print 32 bit number right justified
: /MOD   ( n1 n2 -- n-rem n-quot)    /P49  n_DODOES Divides, remainder and quotient
: */   ( n1 n2 n3 -- result)         /P113 n_DODOES Multply then divide, 32bit intermediate
: 2SWAP   ( d1 d2 -- d2 d1)          /P49  n_DODOES Reverses top two pairs of numbers
: 2DUP   ( d -- d d)                 /P49  n_DODOES Duplicates top pair of numbers
: 2OVER   ( d1 d2 -- d1 d2 d1)       /P49  n_DODOES Duplicates top pairs of numbers
: 2DROP   ( d --)                    /P49  n_DODOES Discards top pair of numbers
: WORD   ( c -- a)                   /P254 n_DODOES read 1 word from input stream
: LIT" xxx"   run-time: ( -- a)      /P254 n_DODOES compiles literal (used in definitions)
: QUIT   ( -- )                      /P221 n_DODOES clear RS, back to monitor
: ABORT   ( -- )                     /P221 n_DODOES Clear DS and then quit
: ASCII   ( -- c)                    /P161 n_DODOES Next input char into ascii equivalent
: CONVERT   ( ud1 a1 -- ud2 a2)      /P254 n_DODOES string to binary value
: BASE   ( -- a)                     /P190 ADRVAR number base
: NUMBER   ( a -- d)                 /P254 n_DODOES using base, convert to binary value
: LOAD   ( n -- )                    /P77  n_DODOES Loads a disk block (compiles or executes) assume (LOAD)
: FLUSH   ( -- )                     /P77  n_DODOES Writes all updated disk buffers to disk, and unassigns
: LOCATE xxx   ( -- )                /P77  n_DODOES Lists block from which xxx has been loaded
: VIEW xxx   ( -- )                  /P77  n_DODOES Lists block from which xxx has been loaded
: UPDATE   ( -- )                    /P254 n_DODOES Most recently referenced block marked modified
: SAVE-BUFFERS   ( -- )              /P254 n_DODOES Writes all updated buffers, un-updated, still assigned
: FLUSH   ( -- )                     /P254 n_DODOES saves then unassigns all buffers
: EMPTY-BUFFERS   ( -- )             /P254 n_DODOES marks all buffers empty without saving
: [']   compile-time: ( -- )         /P221 n_DODOES compiles address of next word in defn as a literal
        run-time: ( -- a)
: LITERAL   compile-time: ( n -- )   /P286 n_DODOES compiles a value
            run-time: ( -- n)
: [   ( -- )                         /P286 n_DODOES leaves compile mode
: ]   ( -- )                         /P286 n_DODOES enters compile mode
: COMPILE xxx   ( -- )               /P286 n_DODOES compile a word
: [COMPILE] xxx   ( -- )             /P286 n_DODOES immediate word gets compiled
: EXECUTE   ( a -- )                 /P221 n_DODOES executes dict entry pfa on stack
: CREATE xxx   ( -- )                /P190 n_DODOES create dictionary header, (xxx returns addr when exec)
         xxx:  ( -- a)
: DOES>   run-time: ( -- a)          /P286 n_DODOES creates defining word, end of compile-time begin of run-time
: ; ( -- )                           /ADD  n_DODOES end of definition (compile exit, so ' EXIT)
: D.   ( d -- )                      /P161 n_DODOES print 32 bit number and 1 space
: ?   ( a -- )                       /P190 n_DODOES prints contents of addr followed by 1 space
: U.   ( u -- )                      /P161 n_DODOES Print unsigned number and space
: ' xxx   ( -- a)                    /P221 n_DODOES find dict address of xxx
: IF xxx   IF: ( ? -- )              /P92  n_DODOES If non zero, executes xxx, otherwise yyy, continues with zzz
  ELSE yyy
  THEN zzz
: DO ... LOOP   DO:                  /P131 n_DODOES Finite loop
                  ( limit index -- )
                LOOP:  ( -- )
: DO ... +LOOP  DO:                  /P131 DODOES Finite stepped loop
                  ( limit index -- )
                +LOOP:  ( n -- )
: LEAVE   ( -- )                     /P131 DODOES Terminate at next LOOP
: BEGIN ... UNTIL   UNTIL: ( ? -- )  /P131 DODOES Indefinite loop exits when ? true
: BEGIN xxx WHILE yyy REPEAT   WHILE:  ( ? -- )   /P131 DODOES Indefinite loop always executes xxx


===== IMPLEMENTATION SPEC =====================================================

----- BEHAVIOUR SPEC OF NATIVE ROUTINES ---------------------------------------

NOTE: the real problem here is that CFA can only ever point to a native routine,
never a threaded instruction list. So, the 'base' code must always be native.
This *might* make it impossible to boot a minimal kernel then extend it incrementally
unless we look into this.


---- READ/WRITE

/todo: endianness?
/pre: stack has at least 2 16-bit items
/pre: address is 16 bit aligned
: n_STORE   ( n a -- )   { a=ds_pop; n0=ds_pop8; n1=ds_pop8; mem[a]=n0; mem[a+1]=n1} ;

/todo: endianness?
/pre: stack has at least 1 16-bit items
: n_FETCH  ( a -- n)   { a=ds_pop; n0=mem[a]; n1=mem[a+1]; ds_push8(n0); ds_push8(n1) } ;

/pre: stack has at least 3 8 bit items
: n_STORE8  ( b a -- )   { a=ds_pop; b=ds_pop8; mem[a]=b } ;

/pre: stack has at least 1 16 bit item
: n_FETCH8   ( a -- b)   { a=ds_pop; b=mem[a]; ds_push8(b) } ;


---- I/O

: n_KEYQ   ( -- ?)   { ds_push8(kbhit) } ;         / how many chars waiting in input stream (could be 0/1 if no lookahead)

: n_KEY   ( -- c)   { ds_push8(getch) } ;          / read next char in input stream, or block

: n_EMIT   ( c -- )   { putch(ds_pop8) } ;        / output 1 char to output stream, block if full


---- ALU

/pre: stack has at least 2 16 bit items
: n_ADD   ( n1 n2 -- n-sum)   { n2=ds_pop; n1=ds_pop; r=n1+n2; flags=zncv; ds_push(r) } ;

/pre: stack has at least 2 16 bit items
: n_SUB   ( n1 n2 -- n-diff)   { n2=ds_pop; n1=ds_pop; r=n1-n2; flags=zncv; ds_push(r) } ;

/pre: stack has at least 2 16 bit items
: n_AND   ( n1 n2 -- n-and)   { n2=ds_pop; n1=ds_pop; r=n1 and n2; flags=zncv; ds_push(r) } ;

/pre: stack has at least 2 16 bit items
: n_OR   ( n1 n2 -- n-or)   { n2=ds_pop; n1=ds_pop; r=n1 or n2; flags=zncv; ds_push(r) } ;

/pre: stack has at least 2 16 bit items
: n_XOR   ( n1 n2 -- n-xor)   { n2=ds_pop; n1=ds_pop; r=n1 xor n2; flags=zncv; ds_push(r) } ;

/pre: stack has at least 2 16 bit items
: n_MULT   ( n1 n2 -- n-prod)   { n2=ds_pop; n1=ds_pop; r=n1*n2; flags=zncv; ds_push(r) } ;

/pre: stack has at least 2 16 bit items
: n_DIV   ( n1 n2 -- n-quot)   { n2=ds_pop; n2=ds_pop; r=n1/n2; flags=zncv; ds_push(c) } ;

/pre: stack has at least 2 16 bit items
: n_MOD   ( n1 n2 -- n-rem)   { n2=ds_pop; n1=ds_pop; r=n1 mod n2; flags=zncv; ds_push(r) } ;

: n_FLAGS   ( -- )   { mem[FLAGS]=flags } ;


--- DATA STACK

TODO: accessing DP will need to be done via a native, as it's an internal register

: n_SWAP   ( n1 n2 -- n2 n1)   { n2=ds_pop; n1=ds_pop; ds_push(n2); ds_push(n1) } ;

/todo: check if dp is next free, or last used
: n_DUP   ( n -- n n)   { n = ds[dp]; ds_push(n) } ;

/todo: check if dp is next free, or last used
/todo: check direction of growth of dp
: n_OVER   ( n1 n2 -- n1 n2 n1)   { n1=ds[dp-2]; ds_push(n1) } ;

: n_ROT   ( n1 n2 n3 -- n2 n3 n1)   { n3=ds_pop; n2=ds_pop; n1=ds_pop; ds_push(n2); ds_push(n3); ds_push(n1) } ;

: n_DROP   ( n -- )   { ds_pop } ;


---- DISK ACCESS

/pre: at least two 16 bit items on stack
/pre: disk block is in range
: n_RBLK  ( n a -- )   { a=ds_pop; n=ds_pop; b=disk_rd(1024*b, mem, a, 1024) } ;       / Load 1K disk block n into memory at addr (see MMSForth)

/pre: at least two 16 bit items on stack
/pre: disk block is in range
: n_WBLK  ( n a -- )   { a=ds_pop; n=ds_pop; disk_wr(1024*b, mem, a, 1024) } ;       / Save 1K memory from addr to disk block n (see MMSForth)





----- BEHAVIOUR CAN BE DEFINED IN HIGH LEVEL WORDS ----------------------------


---- BRANCHING

Behaviour can be defined in high level

as a callable word:
: BRANCH   ( -- ) R@ DUP @ - IP !  ;  / unconditional branch using relative offset in following cell (IP points to it)

/pre: stack has at least 1 byte on it
: n_0BRANCH   ( ? -- )
        { f=ds_pop; r=mem[ip]; if f==0:ip=ip-r else: ip+=2 } ; / branch if TOS=0, using relative offset following


---- VARIABLE ACCESS

Can use to read system variable address, or constant value

/pre: at least 1 16-bit value on DS
/pre: address is 16 bit aligned?
: n_RDPFA   ( a-pfa -- n)   { pfa=ds_pop; r=mem[pfa]; ds_push(r) } ;     / read constant out from PFA and push to DS


/pre: at least 1 16-bit value on DS
/pre: address is 16 bit aligned?

: n_ADRUV   ( a-pfa -- a)   { pfa=ds_pop; rel=mem[pfa]; a=uservars+rel; ds_push(a) } ;       / get address of user variable from offset in PFA and push to DS


---- EXECUTION

Note, all of these can be defined as high level routines

/assume: indirect code points to CFA of word
: NEXT   ( -- )
        / run next high level addr pointed to by IP
        /   IP DUP @ 1 + >R @ ( cfa )   / increment IP, put on return stack, get what at IP which is a CFA of word to execute
        / @ IP @ 1 + IP ! ( code )      / get address to jump to, increment IP to point to PFA
        / JSR                           / call machine code routine, which knows how to interpret from IP


: DODOES   ( -- ) { } ;          / (PFA containing high level thread of CFA addresses, sometimes called ENTER,
                                   / runs high level forth code)
        /                          / repeatedly call NEXT to execute


: EXECUTE   ( -- ) { } ;         / ??? high level? does this do anything extra to above?)

: LIT   ( -- ) { } ;             / put LIT in next IP address on TOS) - is this a native routine or a high level routine?

: EXIT   ( -- ) { ip=rs_pop() } ;


---- CREATIONAL

behaviour of these can *probably* be defined in high level words

: CREATE   ( -- ) { } ;    / root of all creation words, creates a new dict entry

: DOCOL   ( -- ) { } ;     / colon definition, define a new high level word)

: DOCON   ( -- ) { } ;     / ??constant value)

: DOVAR   ( -- ) { } ;     / ??storage for a var) what about uservar and sysvar differences?

: DOVOC   ( -- ) { } ;     / something to do with vocabulary change? could be synthesised?)

: DOLIT   ( -- ) { } ;     / compile a literal at H?)
                             / I thought the DO words were runtime behaviour, not compile time behaviour.
                             / TODO: Do we need a naming convention for compile time words and runtime words?
                             / Remember the immediate bit in the count byte?



===== BEHAVIOUR SPEC OF HIGH LEVEL ROUTINES ===================================

for each word in the synthesisable list, need to show:
- DS before and after
- RS before and after
- DICT before and after
- other side effects
- write a colon definition of it, regardless of whether we will synthesise
  it as a high level word, or write it as a native. It will form a complete
  spec of behaviour. We can resolve dependencies and inefficiencies later.

  In fact, any word could be defined this way, even some of the native ones?
  No point with ALU ops, but some of the others could be specified that way.

===============================================================================
OTHER STUFF, STILL WORKING OUT WHERE IT GOES.

--------
CONSTANT and 2CONSTANT

A constant is compiled into the DICT as follows:

@addr
  name: b NAME
  link: prev
  cfa: @PFA
  pfa: [VALUE]

A 2constant is compiled into the DICT as follows:

@addr
  name: b NAME
  link: prev
  cfa: 2@PFA
  pfa: [VALUEA,VALUEB]

: CFA   ( a-name -- a-cfa)   DUP C@ + 1 + ;
: PFA   ( a-name -- a-pfa)   DUP C@ + 3 + ;
: @PFA   ( a-pfa -- n)   PFA @ ;
: 2@PFA   ( a-pfa -- d)   PFA DUP @ 1 + @ ;

: CONSTANT   ( n -- ) ( name) DOES> ; / TODO
: 2CONSTANT   ( d -- ) ( name) DOES> ; / TODO


---------
VARIABLE and 2VARIABLE

A variable is compiled into the DICT as follows:

@addr
  name: b NAME
  link: prev
  cfa:  PFA
  pfa:  [SPACE]

@addr
  name: b NAME
  link: prev
  cfa: PFA
  pfa [SPACEA, SPACEB]


: VARIABLE   ( -- ) ( name)     DOES> ;
: 2VARIABLE   ( -- ) ( name)    DOES> ;

--------
CODE (non native, i.e. threaded addresses)
  DICT holds {name, link=prev, cfa=pfa, pfa=[code,code,exit]}
  space is ALLOTed inside the pfa of the dict entry for code and final exit (addrs) using COMPILE

HOW CODE works... (BRODIE P205)

EXECUTE of a word will call the machine code pointed to by CFA.
: EXECUTE
  reads cell at IP, pushes value on DS
  adds 1 to IP
  uses cell addr on DS as the CFA of the defined word
  jumps to machinecode routine (special case 0 here does nothing?)

  For defined words, this is a machine code routine for ':'

  ':' is defined in machine code as:
    saves IP onto return stack
    move address of PFA into IP
    call EXECUTE

@addr
  name: b NAME
  link: prev
  cfa: PFA
  pfa: [CODE, CODE, ..., EXIT]

note, interpret loop is:
: INTERPRET ( -- ) BEGIN IP DUP @ SWAP 1 + >R IP ! FALSE UNTIL ;
: EXIT   ( -- )   R> IP ! ;

--------
LITERALS

pfa: [(LITERAL), 65535]
pfa: [(2LITERAL), 65535, 65535]

: (LITERAL)   ( -- n)   R> DUP @ SWAP 1 + IP ! ;
: (2LITERAL)   ( -- d)   R> DUP @ SWAP 1 + @ SWAP 1 + IP ! ;

: LITERAL   ( n -- )   DOES> ; / TODO
: 2LITERAL   ( d -- )  DOES> ; / TODO

/ do all the hard work at compile time
: BEGIN  ( -- )    HERE >R DOES> ;
: UNTIL   ( ? -- )   R> , DOES> (0BRANCH) ;


--------



  LFA Link field points to name field of previous entry

  threads stored in the PFA are pointers to the CFA of the linked word,
  so that no additional maths is required on following the link.

  CFA is a pointer to a machine code routine.

  H points to the last used entry of the dict.
  HERE puts the address stored in H on TOS
  ' gets the PFA address of the word (so that you can write directly to it)
  ! assumes the address is of the bytes to write to
  @ assumes the address on TOS is of the bytes to read from





----- CONSTANT SPEC
constants go in the PFA of the DICT entry
a way to define constants (CONSTANT word)
a CFA way to read constant values from PFA

----- CONSTANT DESIGN

Parser version:
  : CONSTANT word ;

Non parser version, i.e. calling via API direct
  dict.create("constname", " RDPFA", 26)

n_RDPFA - just pushes address of variable on DS, so you can read or write it.


----- VARIABLE SPEC
variables have their own storage space
DICT entry contains address of the variable
a way to allocate space for a variable
difference between sysvars and uservars?
are we going to support multiprogramming of uservars yet?


----- VARIABLE DESIGN

Parser version:
  VARIABLE word - defines a new variable

Non parser version, i.e. calling via API direct
  addr = uv.create(26) # 26 is the value to store there. Size is 16 bit by default.
  dict.create("name", " RDPFA", addr)

n_RDPFA - just pushes address of variable on DS, so you can read or write it.


----- memory mapped constant spec
Just seed the DICT with constants based on the values of system constants,
at boot time.



===============================================================================

----- memory mapped variable spec
Address mapped into low memory, when read/written, causes change of system variable.
DICT wrapped entries that point to these vars, loaded by boot code
These are all uservars at the moment until we investigate sysvars

----- memory mapped variable design

when accessing var, RDPFA gets the PFA and pushes on stack.
This is the address of the variable magic number stored in uservars space.

READING
the CF of @ is n_FETCH (which could be fetching from any address, even a non magic one)
n_FETCH does two 8 bit reads in succession (which is safe), from magicaddr and magicaddr+1
This means that both addresses must be mapped and routed to different halves of the variable

have marked in n_FETCH, n_STORE, n_FETCH8 and n_STORE8 the problem.
These routines, in order to work correctly, have to honour the mapped register
scheme.

perhaps Memory() needs to the indirection for us.
perhaps we need a 16 bit access mode on memory that does the two atomic reads in a single call?
It's indicative that rdbyte() and wrbyte() are not called by any code anywhere!!

WRITING
!
same issues as above

Another way to do this would be to have a special abstraction that has no
storage allocated to it at all, that is mapped as a region in Memory
i.e. a region that has it's own handler.
Then access to any memory address in that part of the map, instead
of going to the bytes list, goes to a read() or write() of the handler,
and it can then lookup things in it's table.

Done this, and it works.
Reads and writes tested, working.

================================================================================

(done)
- 8/16 bit memory mapped variables
I suspect this is wrong, we write a 16 bit number to an 8 bit memory location
and get away with it.

note: we should mask all writes with 0xFF in the low level memory routines

note: need to write a test case for a 16 bit register read and a 16 bit
register write, just to prove that it does work ok in two hits.

- DICT interface for memory mapped variables (DESIGN)
Just like we load dict wrappers for native routines, there needs to be a
walk of the table and a call to something like this to wrap it:
   dict.create(name="SP", CF=RDPFA, PF=getAddr("SP"))
   i.e. variables when accessed just put their address on the stack
   the lower level fetch/store routines then do the access to that address,
   which will be intercepted by the memory handler and the correct value returned,
   which will then probably end up on the stack depending on the operation.
(this is working)

CONSIDERATIONS

- a variable could be of any size (i.e. consider it just a buffer in memory)
- most common size is 16 bits (two separate 8 bit bytes)
- if mapping a whole buffer into memory, having to fill in each byte in a table
  would be a real pain
- the mapping table could be changed to be an address and a length. Finding an
  entry would then be a sequential search through an index to find the matching
  region, and once the region was found, the relative index into that region
  could be passed into the read/write service
- the data structure could be independently optimised once it is working,
  e.g. storing as a tree, storing as a hash table of all possible addresses,
  and this fast search index could be auto generated once the table was
  completed. So it does not have to be designed to be efficient at this stage,
  just designed to be correct.

DESIGN

  MAP inside NvMem

  self.map = [
    ("IP",  0, 2,   rd_ip,  wr_ip),
    ("BUF", 2, 100, rd_buf, wr_buf),
  ]

  SEARCH
  search map sequentially, comparing start, start+size-1
  if address matches, grab this record and process
  process:
    work out relative index into region from start
    if this is a read, call rd_ip(rel)
    if this is a write, call wr_ip(rel)

  rd_ip(rel) -> byte
    low byte or high byte, just access the register using Number.to_bytes()

  wr_ip(rel, byte):
    low byte or high byte, just access the register using Number.to_bytes()/from_bytes()

  rd_buf(rel) -> byte
    rel is index into buffer, just read to it's relative offset address

  wr_buf(rel, byte):
    rel is index into buffer, just write byte to it's relative address

  GENERAL FORM OF INTERFACE ROUTINES
  rd_xx(rel)->byte
  wr_xx(rel, byte)
  call_xx()




VARS/CONSTS REQUIRED
: UV0   ( -- a)                      /ADD  n_RDPFA  CONST  Address of start of user vars
: TIB   ( -- a)                      /P221 n_RDPFA  CONST  Address of start of text input buffer
: TIBZ   ( -- n)                     /ADD  n_RDPFA  CONST  Size of TIB buffer
: PADZ   ( -- n)                     /ADD  n_RDPFA  CONST  Size of PAD buffer
: PAD   ( -- a)                      /P221 n_RDPFA  VAR    Address of scratch area start, note it regularly moves!
: >IN   ( -- a)                      /P254 n_RDPFA  VAR    present char offset in input stream
: COUNT   ( -- a)                    /P243 n_RDPFA  VAR    Address of var containing count of last parsed length
: BLK   ( -- a)                      /P254 n_RDPFA  VAR    number of storage block being interpreted as input stream (0 means IN)
(done)

VARS/CONSTS
\ : BASE   ( -- a)                     /P190 n_RDPFA  CONST  Address of number base variable



NATIVES (done)
n_ABORT   ( -- )                     clear DS and quit to interpreter loop
n_RDPFA   ( -- a)                    read value at PFA and push on DS. Used to read const or varaddr
n_STORE   ( n a -- )                 write n to a
n_FETCH   ( a -- n)                  read a to get n
n_STORE8   ( b a -- )                write b to byte a
n_FETCH8   ( a -- b)                 read byte b from a

DICT wrappers (done)
: ABORT   ( -- )                     /P221 n_ABORT   Clear DS and then quit (RS also?)
: C@   ( a -- c)                     /P190 n_FETCH8  fetch 8 bit value from addr
: !   ( n a -- )                     /P190 n_STORE   store single number into addr
: @   ( a -- n)                      /P190 n_FETCH   replace addr with contents
: C!   ( b a -- )                    /P190 n_STORE8  store 8 bit value
: C@   ( a -- b)                     /P190 n_FETCH8  fetch 8 bit value



================================================================================

DESIGN: Bulk loading of high level const, var, words
- fill in 3 tables
- iterate the tables
- call create_const, create_var, create_word for each
(done)



----- HIGH LEVEL WORDS - DESIGN -----------------------------------------------

(tests must be written for all)

---- CONST

: FALSE   ( -- 0)                    0 ;
: TRUE   ( -- -1)                    -1 ;

----- ALU
: /MOD   ( n1 n2 -- n-rem n-quot)    DUP DUP / ROT ROT MOD SWAP ;
: 1+   ( n -- n+1)                   1 + ;
: 1-   ( n -- n-1)                   1 - ;
: 2+   ( n -- n+2)                   2 + ;
: 2-   ( n -- n-2)                   2 - ;
: 2*   ( n -- n*2)                   2 * ;
: 2/   ( n -- n/2)                   2 / ;
: NEGATE   ( n -- -n)                -1 * ;
: ABS   ( n -- |n|)                  DUP 0< 0BRANCH 2 NEGATE ;
: MIN   ( n1 n2 -- min)              OVER OVER < NOT 0BRANCH 2 SWAP DROP ;
: MAX   ( n1 n2 -- max)              OVER OVER > NOT 0BRANCH 2 SWAP DROP ;

----- STACK OPS
: NIP   ( n1 n2 -- n2)               SWAP DROP ;
: TUCK  ( n1 n2 -- n2 n1 n2)         SWAP OVER ;
: >R   ( n -- )                      RP @ 1 + DUP ROT ! RP ! ;
: R>   ( -- n)                       RP DUP @ @ SWAP 1 - RP ! ;
: R@   ( -- n)                       RP @ @ ;
: SP@   ( -- a)                      SP @ ;
: ?DUP   ( n -- n n or 0 -- 0)       DUP 0BRANCH 2 DUP ;
: 2SWAP   ( d1 d2 -- d2 d1)          ROT >R ROT R> ;
: 2DUP   ( d -- d d)                 OVER OVER ;
: 2OVER   ( d1 d2 -- d1 d2 d1)       2SWAP 2DUP >R >R 2SWAP R> R> ;
: 2DROP   ( d --)                    DROP DROP ;

----- GENERAL I/O
: HEX   ( -- )                       16 BASE ! ;
: OCTAL   ( -- )                     8 BASE ! ;
: DECIMAL   ( -- )                   10 BASE ! ;
: CR   ( -- )                        13 EMIT ;
: SPACE   ( -- )                     32 EMIT ;
: PAGE   ( -- )                      12 EMIT ;

---- SIMPLE MEMORY OPS
: +!   ( n a -- )                    DUP @ ROT + ! ;
: 2!   ( d a -- )                    ROT SWAP DUP ROT SWAP ! 2 + ! ;
: 2@   ( a -- d)                     DUP @ SWAP 2 + @ ;


--------------------------------------------------------------------------------
spec: KEY

waits for next char from keyboard (or KeyboardInput)
need a mocking way of doing this so we can poke keys in from a test script.

design: KEY
- reading from keyboard (KeyboardInput)
  waitch()
  waiting()

- reading from mock buffer (MockKeyboardInput)
  waithch()
  waiting()
  clear()
  append(ch)
  set(str)

test plan: KEY
  override the forth.ins with a MockKeyboardInput() which has some methods
  for clearing, writing strings, and appending to a keyboard buffer that
  is then read by the getch and poll methods.

  write a unit test that pokes known characters into MockKeyboardInput
  and then a test word that reads a few of them out and displays them.





===============================================================================

--------------------------------------------------------------------------------
There is no ( and \commenting,
pass in strings and put # python comments in the API calls for comments, end of line only


--------------------------------------------------------------------------------

code up EXPECT
write a test case for EXPECT
i.e. read a line and then display all chars entered.

----- SPEC: EXPECT (line input buffer)
: EXPECT   ( a # -- )                /P254 n_DODOES wait for chars or newline
: SPAN   ( -- a)                     /P254 ADRVAR number of chars read in expect
: >IN                                /P254 ADRVAR address of next char in input stream
: TIB                                CONST address of start of TIB (absolute address)
: TIBZ                               CONST, size of TIB buffer


Early terminate when TIBZ chars read in.

Q: Is the CR written to buffer (even if full) so we can easily know that INP >IN should terminate?
If so, an 80 char buffer can only hold 79, 1 must be left for the CR worst case.

usage: TIB TIBZ EXPECT

uses >IN as the write pointer, SPAN as the space left counter.
On exit >IN point to start of buffer, SPAN is number of bytes in buffer
(how is buffer terminated, always by a CR?

: EXPECT ( a # -- )
    SPAN ! ( a)                               \ use SPAN as the char counter while in loop
    DUP   ( a a)                              \ leave user buffer start on stack, for later cleanup
    >IN !   ( a)                              \ set INP to start of user buffer, use as write ptr in loop
    \ loop
        KEY   ( a c)                          \ read a char
        DUP   ( a c c)
        >IN @  ( a c c a)                     \ INP is write pointer
        C!   ( a c)                           \ write char to buffer
        >IN @ 1 + !   ( a c)                  \ advance write pointer
        SPAN @ 1 - SPAN !   ( a c)            \ dec counter
        SPAN @ 0=   ( a c ?)                  \ span=0 means buffer full
        NOT 0BRANCH ( exit) 5 ( a c)          \ exit early if yes
        CR ( c c) = ( a ?)                    \ is char a CR?
        0BRANCH ( loop) -21                   \ go round again if it isn't
    \ exit ( a)                               \ address on stack is of start of buffer
    \ >IN points to char after last written
    \ a on stack is start of user buffer
    \ >IN - a is the true SPAN including optional CR
    DUP ( aTIB aTIB)
    >IN @ ( aTIB aTIB aLASTWR+1)
    SWAP ( aTIB aLASTWR+1 aTIB)
    - ( aTIB #read)
    SPAN ! ( aTIB)                            \ SPAN holds number of chars read in
    >IN !                                     \ INP points to first char to read in buffer


----- DESIGN: test harness for EXPECT

: TEST TIB TIBZ EXPECT TIB SPAN SHOW ;

: SHOW                                  # ( a # -- )
                                        # target:read
    DUP                                 # ( a #)
    DUP 0= NOT 0BRANCH 12               # (exit) ( a #) if counter zero, exit
    SWAP DUP C@                         # ( # a c)      read char at address
    EMIT                                # ( # a)        show char
    1 +                                 # ( # a)        advance address
    SWAP                                # ( a #)
    1 -                                 # ( a #)        dec count
    BRANCH -16                          # (read)        go round for another
                                        # target:exit

: ECHO
                                        # target:loop
    TIB TIBZ EXPECT                     # get a line
    TIB SPAN SHOW                       # show a line
    BRANCH -7                           # loop


test: SHOW fill TIB with data 0123456789

48 SPAN !                       # init value to 48
TIB >IN !                       # init ptr to TIB
9 COUNT !                       # init count to 9
                                # target:loop
COUNT @ 0= NOT 0BRANCH 19       # if count 0, exit
SPAN C@ >IN !                   # store value at addr
>IN @ 1 + >IN !                 # inc ptr
COUNT @ 1 - COUNT !             # dec count
BRANCH -23                      # to:loop
                                # target:exit
TIB >IN !
9 COUNT !

self.f.machine.tib.dumpraw()

TIB COUNT SHOW


----- spec: COUNT

Converts address of a counted string, to stack ( a #)
: COUNT   ( a -- a+1 #)              /P254 n_DODOES convert counted string into TYPE expected format


----- design: COUNT

: COUNT DUP C@ SWAP 1 + SWAP ;
