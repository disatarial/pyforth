/ design.txt  30/12/2015  D.J.Whale

PLAN see ####HERE#### - buffer handling for 'WORD'

----- SPECIFICATION

Define all the high level words
- It's looking like IF ELSE THEN is critical to the implementation of a number of
high level words, and it's got some complex semantics in terms of resolving two
different forward jump targets. It's synthesisable using 0BRANCH, but need to
think carefully through the jump target resolution, as it needs to be used
as an immediate word (not compiled in, but actually executed??)

These could be synthesised with 0BRANCH and some hard coded targets in the
first pass while working at this lower API level

i.e., could re-code all these using 0BRANCH with hand calculated jump targets



----- IMPLEMENTATION

Signed/Unsigned on ALU ops.

Defining normal constants

Defining normal variables (perhaps merge the SysVars and UserVars into one for now
to simplify the model)

Memory mapping constants and variables (specifically IP and H) to pave the way
for compilation.

Outer loop constructs.

Input stream redirection (so we can implement LOAD to get code from a saved
disk block) - although don't really need this until we write the interpreter.

Write the outer interpreter with interactive mode
(perhaps do this sooner, as it gives us a good proper test interface a bit
like the python shell does). Really want this to be in high level, so we
need unconditional branching in order to do this.

Some of the API seeded words could be re-defined symbolically later when the interpreter/
compiler is booted.



================================================================================

MORE NATIVES REQUIRED:

: BASE   ( -- a)                     /P190 n_ADRVAR number base
: FLAGS  ( -- n)                     /ADD  n_RDPFA  Address of flags variable
: BB0      ( -- a)                   /ADD  n_ADRVAR address of first byte of block buffers
: UV0   ( -- a)                      /ADD  n_RDPFA  Address of start of user vars
: >IN   ( -- a)                      /P254 n_ADRVAR present char offset in input stream
: PAD   ( -- a)                      /P221 n_ADRVAR addr of scratch area start
: TIB   ( -- a)                      /P221 n_ADRVAR Address of start of text input buffer
: BINDEX ( -- a)                     /ADD  n_ADRVAR array of block buffer index info (0 not loaded)
: BLK   ( -- a)                      /P254 n_ADRVAR number of storage block being interpreted as input stream (0 means IN)

: ABORT   ( -- )                     /P221 n_DODOES Clear DS and then quit
: (LOADED) ( n b ? -- )              /ADD  n_DODOES block buffer loaded or unloaded?

: NUMBER   ( a -- d)                 /P254 n_DODOES using (any) base, convert string at a, to binary value



----- HIGH LEVEL WORDS - BEHAVIOUR SPEC ---------------------------------------

---- CONST

: FALSE   ( -- 0)                    0 ;
: TRUE   ( -- -1)                    -1 ;

----- ALU
: /MOD   ( n1 n2 -- n-rem n-quot)    DUP DUP / ROT ROT MOD SWAP ;
: 1+   ( n -- n+1)                   1 + ;
: 1-   ( n -- n-1)                   1 - ;
: 2+   ( n -- n+2)                   2 + ;
: 2-   ( n -- n-2)                   2 - ;
: 2*   ( n -- n*2)                   2 * ;
: 2/   ( n -- n/2)                   2 / ;
: NEGATE   ( n -- -n)                -1 * ;
: ABS   ( n -- |n|)                  DUP 0< 0BRANCH 2 NEGATE ;
: MIN   ( n1 n2 -- min)              OVER OVER < NOT 0BRANCH 2 SWAP DROP ;
: MAX   ( n1 n2 -- max)              OVER OVER > NOT 0BRANCH 2 SWAP DROP ;

----- STACK OPS
: NIP   ( n1 n2 -- n2)               SWAP DROP ;
: TUCK  ( n1 n2 -- n2 n1 n2)         SWAP OVER ;
: >R   ( n -- )                      RP @ 1 + DUP ROT ! RP ! ;
: R>   ( -- n)                       RP DUP @ @ SWAP 1 - RP ! ;
: R@   ( -- n)                       RP @ @ ;
: SP@   ( -- a)                      SP @ ;
: ?DUP   ( n -- n n or 0 -- 0)       DUP 0BRANCH 2 DUP ;
: 2SWAP   ( d1 d2 -- d2 d1)          ROT >R ROT R> ;
: 2DUP   ( d -- d d)                 OVER OVER ;
: 2OVER   ( d1 d2 -- d1 d2 d1)       2SWAP 2DUP >R >R 2SWAP R> R> ;
: 2DROP   ( d --)                    DROP DROP ;

----- GENERAL I/O
: HEX   ( -- )                       16 BASE ! ;
: OCTAL   ( -- )                     8 BASE ! ;
: DECIMAL   ( -- )                   10 BASE ! ;
: CR   ( -- )                        13 EMIT ;
: SPACE   ( -- )                     32 EMIT ;
: PAGE   ( -- )                      12 EMIT ;

---- SIMPLE MEMORY OPS
: +!   ( n a -- )                    DUP @ ROT + ! ;
: 2!   ( d a -- )                    ROT SWAP DUP ROT SWAP ! 2 + ! ;
: 2@   ( a -- d)                     DUP @ SWAP 2 + @ ;


===============================================================================


----- PARSING
### Need input stream redirection architecture in place
# need an input buffer that stores a whole line (e.g. up to 80 chars)
# this needs a start address, an active length, and a pointer to the next char to process

# note, if using LOAD to load and interpret a disk block, how would that work?
# presumably the disk block is loaded into a buffer, then the line pointer address is pointed
# at the start of the block, then the interpreter runs. So, stream redirection
# is just about being able to change the current address pointer for the
# interpreter buffer.

# do we need to copy chars? Probably not, but it depends on how the length of the word
# is signalled to the caller - if the address is on the stack, where is the count?
# if the count byte preceeds the word in the buffer, can't do this because if word
# is at first byte in buffer, nowhere to put the count byte (unless you reserve
# one character at start of buffer for this, but in-place modification of
# block buffers on LOAD could be dangerous.

####HERE#### Check Brodie to see if there is any knowledge on the WORD parser,
# how it uses the buffer, what it returns and how the count is communicated.



: WORD   ( c -- a)                   /P254 n_DODOES read 1 word from input stream (presumably into PAD?)

# does this assume a whole line is already in the IN buffer? Yes
# can words span lines - no, newline (and therefore end of buffer) terminates word
# can we arrange for the 'most full buffer' to always have a newline at end? Not sure.

# skip whitespace
#   look at present input stream pointer
#   until end of buffer, skip spaces tabs and newlines at start
#   if end of buffer (must be newline? what if newline before seen a word?)
# once seen non whitespace, capture word chars
#   if space tab or newline, at end of word
#   munch next character into pad and advance pointer and count
#   loop back
# got a word
#   push start address of word on DS
#   note, how is the length of string known, is it count byte preceeded or zero terminated?
#   note, this doesn't need to copy chars to pad, all it needs to do is to get the
#   address of the start

===============================================================================


: ( xxx)   ( -- )                    /P26  n_DODOES Comment, terminated by )
: \                                  comment to end of line being parsed

: INTERPRET   ( -- )                 /P286 n_DODOES text interpret input stream until exhausted

----- CONDITIONS
#### Need parser

: IF xxx ( ? -- )                    /P92  n_DODOES If non zero, executes xxx, otherwise yyy, continues with zzz
  ELSE yyy                           / use 0BRANCH to write this
  THEN zzz

----- LOOPS
### Need parser
: I ( -- n)                          /P207 n_RDPFA loop counter
: J ( -- n)                          /P207 n_RDPFA loop counter
: DO ... LOOP   DO:                  /P131 n_DODOES Finite loop
                  ( limit index -- )
                LOOP:  ( -- )
: DO ... +LOOP  DO:                  /P131 DODOES Finite stepped loop
                  ( limit index -- )
                +LOOP:  ( n -- )
: LEAVE   ( -- )                     /P131 DODOES Terminate at next LOOP
: BEGIN ... UNTIL   UNTIL: ( ? -- )  /P131 DODOES Indefinite loop exits when ? true
: BEGIN xxx WHILE yyy REPEAT   WHILE:  ( ? -- )   /P131 DODOES Indefinite loop always executes xxx

#### Gets hard from here downwards ********************************************
# Need to build up some more support in proper loops and proper conditions
# and possibly using a parser first,
to make all of this 'real algorithmic code' easier to bootstrap

#### Need loops
: SPACES   ( n -- )                  /P26  n_DODOES Blank spaces #### need LOOP
: TYPE   ( a # -- )                  /P254 n_DODOES transmits # chars starting at addr
: >TYPE   ( a # -- )                 /P254 n_DODOES output string moved to PAD before output
: EXPECT   ( a # -- )                /P254 n_DODOES wait for chars or newline
: SPAN   ( -- a)                     /P254 ADRVAR number of chars read in expect (implies base+pointer)

#### Needs input parser
: ASCII   ( -- c)                    /P161 n_DODOES Next input char into ascii equivalent

----- STRING PROCESSING
#### Needs loops
: COUNT   ( a -- a+1 #)              /P254 n_DODOES convert counted string into TYPE expected format
: -TRAILING   (a #1 -- a #2)         /P254 n_DODOES eliminates trailing blanks from string
: -TEXT   ( a1 # a2 -- ?)            /P254 n_DODOES compare strings
: -MATCH   ( d # s # -- a ?)         /P254 n_DODOES search for string
: CONVERT   ( ud1 a1 -- ud2 a2)      /P254 n_DODOES string to binary value

----- OUTPUT CONVERSION AND FORMATTING
#### Needs loops and conditions
: ?   ( a -- )                       /P190 n_DODOES prints contents of addr followed by 1 space
: .( text)   ( -- )                  /P77  n_DODOES Display text
: ." xxx"   ( -- )                   /P26  n_DODOES Displays the character string xxx. The " character terminates the string
: .   ( n -- )                       /P26  n_DODOES Display number followed by a space
: D.   ( d -- )                      /P161 n_DODOES print 32 bit number and 1 space
: U.   ( u -- )                      /P161 n_DODOES Print unsigned number and space
: <#                                 /P161 n_DODOES Begin number conversion
: #                                  /P161 n_DODOES Convert one digit into output char string
: #S                                 /P161 n_DODOES Convert until result is zero
: c HOLD                             /P161 n_DODOES Insert char
: n SIGN                             /P161 n_DODOES Insert minus sign
: #>                                 /P161 n_DODOES End conversion
: <# ... #>   ( d -- a u)            /P161 n_DODOES 32 bit unsigned
              ( u 0 -- a u)          /P161 n_DODOES 16 bit signed
: <# ... n SIGN #>   ( |d| -- a u)   /P161 n_DODOES 32 bit signed
                or   ( |d| 0 -- a u) /P161 n_DODOES 16 bit signed
: U.R   ( u width -- )               /P161 n_DODOES Print unsigned number right justified
: .R   ( n width -- )                /P131 n_DODOES Prints number right justified to width
: D.R   ( d width -- )               /P161 n_DODOES print 32 bit number right justified

----- MEMORY OPS
#### Needs loops
: BLANK   ( a # -- )                 /P254 n_DODOES fills with ascii 0
: MOVE   ( a1 a2 # -- )              /P254 n_DODOES copy region of memory
: CMOVE   ( a1 a2 # -- )             /P254 n_DODOES copy char region of memory
: CMOVE>   ( a1 a2 # -- )            /P254 n_DODOES copy char region of memory backwards
: FILL   ( a u b -- )                /P190 n_DODOES fills u bytes of memory
: ERASE   ( a u -- )                 /P190 n_DODOES zeros n bytes of memory
: DUMP   ( a u -- )                  /P190 n_DODOES display u bytes of memory

----- DISK I/O

: BLOCK   ( u -- a)                  /P254 n_DODOES 1024 * BB0 + ;

#### Needs loops
: TRIAD   ( n -- )                   /P77  n_DODOES Displays 3 blocks
: SHOW   ( lo hi -- )                /P77  n_DODOES Lists in triad form
: INDEX   ( lo hi -- )               /P77  n_DODOES Displays comment lines only
: LIST   ( n -- )                    /P77  n_DODOES Lists a disk block
: THRU   ( lo hi -- )                /P77  n_DODOES Loads all blocks inclusive
: BUFFER   ( u -- a)                 /P254 n_DODOES like block, not necc read from mass storage
: LOAD   ( n -- )                    /P77  n_DODOES Loads a disk block (compiles or executes) assume (LOAD)
: FLUSH   ( -- )                     /P77  n_DODOES Writes all updated disk buffers to disk, and unassigns
: LOCATE xxx   ( -- )                /P77  n_DODOES Lists block from which xxx has been loaded
: VIEW xxx   ( -- )                  /P77  n_DODOES Lists block from which xxx has been loaded
: UPDATE   ( -- )                    /P254 n_DODOES Most recently referenced block marked modified
: SAVE-BUFFERS   ( -- )              /P254 n_DODOES Writes all updated buffers, un-updated, still assigned
: FLUSH   ( -- )                     /P254 n_DODOES saves then unassigns all buffers
: EMPTY-BUFFERS   ( -- )             /P254 n_DODOES marks all buffers empty without saving

----- EXECUTING

: QUIT   ( -- )                      /P221 n_DODOES clear RS, back to monitor
: (EXECUTE)   ( a -- )               /ADD  n_DODOES execute from address (IP !)
: @EXECUTE   ( a -- )                /P221 n_DODOES executes dict entry pfa pointed to by contents of a, nothing if zero
: ABORT" xxx"   ( ? -- )             /P92  n_DODOES If flag true, shows last word and text, clears user stacks, back to terminal.

----- CREATIONAL
: CONSTANT xxx   ( n -- )            /P190 n_DODOES create constant with a value
           xxx:  ( -- n)
: VARIABLE xxx   ( -- )              /P190 n_DODOES create variable (returns addr when exec)
           xxx: ( -- a)
: 2VARIABLE xxx   ( -- )             /P190 n_DODOES create double length var, addr when exec
            xxx:  ( -- a)
: 2CONSTANT xxx   ( d -- )           /P190 n_DODOES create double length const with value
            xxx:  ( -- d)

----- COMPILATION
: HERE   ( -- a)                     /P221 n_RDPFA Next available dictionary location (H @)
: RECURSE ( -- )                     /P211 n_DODOES compile address of the word being defined, to allow recursion
: CONTEXT   ( -- a)                  /P221 n_DODOES address of var that specifies dict search order
: CURRENT   ( -- a)                  /P221 n_DODOES addr of var specifying the vocab for new defns
: STATE   ( -- a)                    /P286 ADRVAR true if compiling, false if interpreting
: >BODY   ( cfa -- pfa)              /P221 n_DODOES pfa address of cfa address
: LIT" xxx"   run-time: ( -- a)      /P254 n_DODOES compiles literal (used in definitions)
: LITERAL   compile-time: ( n -- )   /P286 n_DODOES compiles a value
            run-time: ( -- n)
: [']   compile-time: ( -- )         /P221 n_DODOES compiles address of next word in defn as a literal
        run-time: ( -- a)
: [   ( -- )                         /P286 n_DODOES leaves compile mode
: ]   ( -- )                         /P286 n_DODOES enters compile mode
: COMPILE xxx   ( -- )               /P286 n_DODOES compile a word
: [COMPILE] xxx   ( -- )             /P286 n_DODOES immediate word gets compiled
: FORGET name   ( -- )               /P77  n_DODOES Removes all dict entries up to and including this one
: ALLOT   ( n -- )                   /P190 n_DODOES adds n bytes to parameter field of most recently defined word
: ,   ( n -- )                       /P190 n_DODOES compiles n into next available cell in dict
: C,   ( b -- )                      /P190 n_DODOES compiles b into next available byte in dict
: STRING   ( c -- )                  /P254 n_DODOES compiles string literal into dict as counted string
: IMMEDIATE   ( -- )                 /P286 n_DODOES marks recently defined word by setting immediate bit
: DOES>   run-time: ( -- a)          /P286 n_DODOES creates defining word, end of compile-time begin of run-time
: CREATE xxx   ( -- )                /P190 n_DODOES create dictionary header, (xxx returns addr when exec)
         xxx:  ( -- a)
: ; ( -- )                           /ADD  n_DODOES end of definition (compile exit, so ' EXIT)
: ' xxx   ( -- a)                    /P221 n_DODOES find dict address of xxx

----- ALU/DOUBLES
: C?   ( -- ?)                       /ADD  n_DODOES query C flag in FLAGS var
: V?   ( -- ?)                       /ADD  n_DODOES query V flag in FLAGS var
: Z?   ( -- ?)                       /ADD  n_DODOES query Z flag in FLAGS var
: P?   ( -- ?)                       /ADD  n_DODOES query P flag in FLAGS var
: 0.  ( -- 0 0)                      0 0 ;
: D+   ( d1 d2 -- dsum)              /P161 n_DODOES adds 32 bit (synth if carry?)
: D-   ( d1 d2 -- d-diff)            /P161 n_DODOES subtracts 32 bit (synth if carry?)
: D0=   ( d -- ?)                    /P161 n_DODOES true if zero
: D=   ( d1 d2 -- ?)                 /P161 n_DODOES equality check
: D<   ( d1 d2 -- ?)                 /P161 n_DODOES true if less
: DU<   (ud1 ud2 -- ?)               /P161 n_DODOES true if unsigned less
: DNEGATE   ( d -- -d)               /P161 n_DODOES negates 32 bit
: DABS   ( d -- |d|)                 /P161 n_DODOES absolute of 32 bit
: DMAX   ( d1 d2 -- d-max)           /P161 n_DODOES max of 32 bit
: DMIN   ( d1 d2 -- d-min)           /P161 n_DODOES min of 32 bit

----- NATIVES: ALU/multiply/divide
: */   ( n1 n2 n3 -- result)         /P113 n_DODOES Multply then divide, 32bit intermediate
: */MOD   ( n1 n2 n3 -- n-rem n-result)   /P113 n_DODOES Multiply then divide, double length intermediate
: UM*   ( u1 u2 -- ud)               /P161 n_DODOES multiply 16 bit, 32 bit result
: UM/MOD   ( ud u1 -- u2 u3)         /P161 n_DODOES divide mod 16 bit, 32 bit result
: M*   ( n1 n2 -- d-prod)            /P161 n_DODOES multiply 16 bit, 32 bit result
: M+   ( d n -- d-sum)               /P161 n_DODOES 32bit add to 16 bit 32 bit result
: M/   ( d n -- n-quot)              /P161 n_DODOES 32bit divide 16 bit, 32 bit result
: M*/   ( d n u -- d)                /P161 n_DODOES mult 32 bit number by 16 bit, 32 bit result

----- VOCAB
: FORTH   ( -- )                     /P221 n_DODOES Make forth context vocab
: EDITOR   ( -- )                    /P221 n_DODOES Make editor the context vocab
: ASSEMBLER   ( -- )                 /P221 n_DODOES Make assembler the context vocab
: DEFINITIONS   ( -- )               /P221 n_DODOES sets current vocab to context vocab








------ DODOES -----------------------------------------------------------------

- read the DODOES in brad rodrigez "moving forth ch 3"
  basically DODOES arranges for the IP to be the PFA following, and then does NEXT
  to start executing high level code from there.
  so DOES> puts the address of DODOES in the next defined cell, and then
  the following high level actions are compiled after it.
  ; compiles in an EXIT (basically a high level return)

DOES> is executed during Sequence 1, when CONSTANT is compiled. Thus DOES> is a Forth IMMEDIATE word. It does two things:

a. It compiles the Forth word (DOES>) into CONSTANT.
b. It compiles a JSR DODOES into CONSTANT.

Because DOES> is marked as immediate, when used in a definition, instead of being copied into the definition,
it actually executes (and then puts the DOES> and JSR DODOES)

So, any non immediate words are copied into the PFA, any immediate words are executed.
Those immediate words run code at compile time, rather than deferring the code to runtime.


-------------------------------------------------------------------------------

- investigate and write/test creational words, so we can seed the dictionary

: n_CREATE   ( -- )                 { } ;     / root of all creation words, creates a new dict entry
: n_DOCOL   ( -- )                  { } ;     / colon definition, define a new high level word
: n_DOCON   ( -- )                  { } ;     / create a new constant value
: n_DOVAR   ( -- )                  { } ;     / create a new uservar in usertable


- seed the dictionary with definitions for system constants
: SV0   ( -- a)                      /ADD  CODE 'n_RDPFA' Address of start of system vars
: D0   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of bottom of dictionary
: H    ( -- a)                       /P213 CODE 'n_RDPFA' Address of variable holding next free dict addr
: S0   ( -- a)                       /P221 CODE 'n_RDPFA' Address of bottom of data stack
: SP   ( -- a)                       /P215 CODE 'n_RDPFA' Address of data stack pointer var
: R0   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of bottom of return stack
: RP   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of return stack pointer var
: IP   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of instruction pointer var
: 0   ( -- 0)                        /P190 CODE 'n_RDPFA' const zero
: 1   ( -- 1)                        /P190 CODE 'n_RDPFA' const 1

- seed the dictionary with definitions for system variables
: BB0   ( -- a)                      /ADD CODE 'n_RDPFA' Lowest address of start of 1K block buffers
: BBN   ( -- #)                      /ADD CODE 'n_RDPFA' Number of 1K block buffers

- seed the dictionary with definitions for user variables
(eventually, add BASE, but not yet)

- seed the dictionary with definitions for nucleus words
: !   ( n a -- )                     /P190 CODE 'n_STORE'  store single number into addr
: @   ( a -- n)                      /P190 CODE 'n_FETCH'  replace addr with contents
: C!   ( b a -- )                    /P190 CODE 'n_STORE8' store 8 bit value
: C@   ( a -- b)                     /P190 CODE 'n_FETCH8' fetch 8 bit value
: KEY?  ( -- ?)                      /ADD  CODE 'n_KEYN' Check if a key is waiting
: KEY   ( -- c)                      /P254 CODE 'n_KEY'  Get next char from input
: EMIT   ( c -- )                    /P26  CODE 'n_EMIT' Send character to output
: SWAP   ( n1 n2 -- n2 n1)           /P49  CODE 'n_SWAP' Reverse top two stack items
: DUP   ( n -- n n)                  /P49  CODE 'n_DUP'  Duplicate top stack item
: OVER   ( n1 n2 -- n1 n2 n1)        /P49  CODE 'n_OVER' Make a copy of second item and puts on top
: ROT   ( n1 n2 n3 -- n2 n3 n1)      /P49  CODE 'n_ROT'  Rotate 3rd item to top
: DROP   ( n -- )                    /P49  CODE 'n_DROP' Discard top item
: +   ( n1 n2 -- n-sum)              /P49  CODE 'n_ADD'    Add
: -   ( n1 n2 -- n-diff)             /P49  CODE 'n_SUB'    Subtract (n1 - n2)
: AND   ( n1 n2 -- n-and)            /P92  CODE 'n_AND'    Logical AND
: OR   ( n1 n2 -- n-or)              /P92  CODE 'n_OR'     Logical OR
: XOR   ( n1 n2 -- n-xor)            /P92  CODE 'n_XOR'    Logical XOR
: *   ( n1 n2 -- n-prod)             /P49  CODE 'n_MULT'   Multiply
: /   ( n1 n2 -- n-quot)             /P49  CODE 'n_DIV'    Divide (n1/n2)
: MOD   ( n1 n2 -- n-rem)            /P49  CODE 'n_MOD'    Remainder from division (n1/n2)
: FLAGS  ( -- a)                     /ADD  CODE 'n_RDPFA'  Address of var of flags from last saved ALU operation
: FLAGS>   ( -- )                    /ADD  CODE 'n_FLAGS'  Save last ALU C,V,Z,P flags to FLAGS
: BRANCH                             /ADD CODE 'n_BRANCH'  branch using relative offset following
: 0BRANCH                            /ADD CODE 'n_BRANCH0' branch if TOS=0, using relative offset following
: RBLK  ( n a -- )                   /ADD CODE 'n_RBLK'    Load 1K disk block n into memory at addr (see MMSForth)
: WBLK  ( n a -- )                   /ADD CODE 'n_WBLK'    Save 1K memory from addr to disk block n (see MMSForth)


===== CORE DATA STRUCTURES ====================================================



----- DICTIONARY --------------------------------------------------------------

dictionary has
  header(name, link)
  body(code, param)

NFA - Name field address (name)
LFA - link field address (link) points to NFA of previous entry (holds 0 at end)
CFA - code field address (code)
PFA - parameter field address (parameters)

CFA (CODE) is address of assembly routine
PFA (PARAMETERS) are parameters to the routine
(i.e. parameters always follow the code address, rather than being pushed on stack)
code field is class method (action), parameters are instance variables
(so it's object oriented)


All of the "hard work" of a defining word is done by a kernel word, CREATE, which parses a
name from the input stream, builds the header and Code Field for a new word, and links it into the
dictionary. (In fig-Forth this word is called <BUILDS.)


----- USER VARIABLE TABLE ----------------------------------------------------------

For tasking (multi programming), each user task needs its own user variable table,
and variables must be stored as offsets into this table rather than absolute addresses.
That way, each task can have it's own instance of a user variable.

System variables are shared between all tasks, as is the dictionary.

Not sure yet what happens about parameter stack and return stack, block buffers, pad, tib,
need to look into various multi-programmed forth designs first to see how that works.

USER VARIABLES - see BRODIE P 218 (to do with multi tasking)
  DICT entry points to VARIABLE CODE
  PFA contains offset into USER TABLE
  USER TABLE stores actual value.

  This means that the baseaddr of the USER TABLE can be changed
  between each USER (TASK), the dict is shared, but the user table
  is unique for each user/task. e.g. BASE is defined in the USER TABLE.
  Not defined using VARIABLE (ordinary variable).
  (This will be useful for multi-instanced pyforth objects that share the
  same memory image and runtime for expediency)

  Q? So how are these defined?


===== MACHINE CODE ============================================================

CFA is always the address of a machine code routine to call when executing a word.

For a machine code word
  put addr of PFA in CFA
  store machine code in PFA
  ending with JMP EXIT

For a high level routine:
  put addr of DODOES in CFA
  list of CFA word addresses in PFA
  end with CFA(EXIT)

: DODOES ( machine code)
  Push PFA onto DS?
  Pop CPU stack to get address of high level action routine (this is the PFA)
  Save old IP on RS
  load address of high level thread (PFA) into IP
  NEXT to continue interpretation at IP


DOES> and (DOES>)

: CONSTANT ( n -- )
    CREATE      \ create the new word
    ,           \ append the TOS value to the dictionary,
                \   as the 1st cell of the Parameter Field
    DOES>       \ end "create" part & start "action" part
    @           \ given the PFA, fetch its contents
    ;

(everything from : to DOES> is executed when CONSTANT is executed, and it builds the parameter
field of the defined word.

Everything from DOES> to ; is high level code that is executed when children of CONSTANT
get executed, i.e. the high level fragment that it's CFA will point to.

i.e. the create part, and the action part.
The create part is run at creation time.
The action part is run at runtime of the created word.


DOES> is executed when CONSTANT is compiled. Thus DOES> is a Forth IMMEDIATE word. It does two things:

a. It compiles the Forth word (DOES>) into CONSTANT.
b. It compiles a JSR DODOES into CONSTANT.

Note that DOES> leaves the Forth compiler running, in order to compile the high-level fragment which follows.
Also, even though JSR DODOES is not itself Forth code, an IMMEDIATE word such as DOES> can cause it to be compiled
in the middle of Forth code.


(DOES>) is part of the word CONSTANT, so it executes when CONSTANT executes. It does the following:

a. It gets the address of the machine code that immediately follows (JSR DODOES), by popping IP from the
Forth Return Stack.

b. It puts that address into the Code Field of the word just defined by CREATE.

c. It performs the action of EXIT, causing CONSTANT to terminate here and not attempt to execute the fragment
that follows.

NFA:   8,CONSTANT
LFA:   prev
CFA:   addr(DOCOL)
PFA:   <-- create part -->
       CFAof CREATE
       CFAof ,
       CFAof (DOES>)
       <-- "DOCON" action routine -->
       CFA: JSR DODOES
       PFA: CFAof @
            CFAof EXIT

3 parts of the defining lifecycle
sequence 1: CONSTANT is being defined
sequence 2: CONSTANT is being executed
sequence 3: constant-type word is being executed

Address of a word is the address of it's CFA
tick returns PFA

branching words as compiled into PFA are followed by a branch offset???

LOOP is an immediate word that compiles in a (LOOP)
." is an immediate word that compiles in (.")


----- NATIVE CALLS ------------------------------------------------------------

read CFA number means load from that address
at that address in low memory (e.g. 2) could be a FF 02 e.g.(TRAP 02)
causes python to index into a list of functions
2 in the list is ("DOCON", docon)
when building that dict entry at nucleus boot,
search for "DOCON" and store 2 in the DICT to complete the circle.
When the docon() returns, it returns to the python loop that is driving
the forth, so it will all just tick away nicely.

The native words are then just defined as normal functions with a simple
dispatch table and dispatcher function in the CFA handler. Then all we
have to do is work out the minimum number of native functions required
to allow all other functions to be synthesisable as high level code
for an initial quick port.

Porting to a new language then becomes
- translate the forth.py into the new target language
- including translating the native functions into new target language
- including knitting up in/out/disk to target IO
- run it, and it should self boot.

Other languages to try ports for: java, C, php, lua, javascript
php and javascript are interesting because it allows use in web context
including server side and browser side.

Could then write an in-browser forth system that could be used by people
learning the language, and for experimentation. Python is then the first
port and the initial specification validation language.

If want to later write a 6502 simulator or any processor simulator, could
still do it, it could be extended to that.


===== INTERFACE SPEC ==========================================================

PLAN:
1. define everything in forth, ignoring dependencies
2. make sure sorting is correct for good boot order
3. spot bad dependencies with a dependency tool (def some to break dependencies)
   This is just like the dependency sorter in the excel2php converter we wrote.
4. write native implementations to break bad dependencies
5. write boot code in python to get nano kernel booted into memory


----- NANO KERNEL ---------------------------------------------------------------------

This is a non optimal list, but a good first stab at a minimal kernel
that is required to build up the next layers.

The whole point is to define as little as possible natively to allow fast porting,
and then optimise later when on a real platform and have an appropriate assembler
written, to replace synthesised versions with platform specific assembled versions.


----- NATIVE ROUTINE INTERFACE SPEC -------------------------------------------

(39 in list, 78 bytes of MEM at start for vectors if use vectors?)
Only need to use vectors if might want to insert a CPU simulator later.
If don't want that, just 'running native' a number stored at CFA will do it.
Could be a build option to save a level of indirection if no CPU simulator
required. i.e. does CFA store address of machine code, or machine code instruction
(direct, indirect, subroutine option)

NOP       (does nothing)
--- memory read/write
STORE     (store 16bit at address)
FETCH     (read 16 bit from address)
STORE8    (store 8 bit at address)
FETCH8    (read 8 bit from address)
--- I/O
KEY?      (checks number of keys waiting in input stream)
KEY       (removes next key from input stream)
EMIT      (writes one byte to output stream)
--- ALU
ADD       (add top two stack items, if exists)
SUB       (subract top two stack items, if exists)
AND       (bit-and top two stack items, if exists)
OR        (bit-or top two stack items, if exists)
XOR       (bit-xor top two stack items, if exists)
MULT      (16 bit multiply top two stack items, if exists)
DIV       (16 bit divide top two stack items, if exists)
MOD       (remainder from 16 bit divide top two stack items, if exists)
FLAGS     (update FLAGS variable from last operation)
--- branching
BRANCH    (unconditional branch based on relative stored in next IP)
BRANCH0   (branch only if tos=0 based on relative stored in next IP)
--- data stack access
SWAP      (swap top two items on stack if exists)
DUP       (copy top item to top of DS if exists)
OVER      (copy 2nd item to top of DS if exists)
ROT       (rotate 3 items on top of DS if exists)
DROP      (remove top of DS if exists)
--- disk block access
RBLK      (read a disk block)
WBLK      (write a disk block)

--- variable table access
RDPFA     (read constant out from PFA and push to DS)
RDPFAREL  (read constant from PFA, add onto user variable table base, push address to DS)
--- executional words
NEXT      (run next high level addr pointed to by IP)
DODOES    (PFA containing high level thread of CFA addresses, sometimes called ENTER, runs high level forth code)
EXIT      (pops IP from return stack and jumps to NEXT)
EXECUTE   (??? high level? does this do anything extra to above?)
LIT       (put LIT in next IP address on TOS) - is this a native routine or a high level routine?
--- creational words
CREATE    (??root of all creation words)
DOCOL     (colon definition, define a new high level word)
DOCON     (??constant value)
DOVAR     (??storage for a var)
DOVOC     (something to do with vocabulary change? could be synthesised?)
DOLIT     (compile a literal at H)


----- MANUALLY BOOTED DICT SPEC -----------------------------------------------

These instructions will be hand-generated into the dictionary by the platform language

-------- initial constants and variables
: SV0   ( -- a)                      /ADD  CODE 'n_RDPFA' Address of start of system vars
: D0   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of bottom of dictionary
: H    ( -- a)                       /P213 CODE 'n_RDPFA' Address of variable holding next free dict addr
: S0   ( -- a)                       /P221 CODE 'n_RDPFA' Address of bottom of data stack
: SP   ( -- a)                       /P215 CODE 'n_RDPFA' Address of data stack pointer var
: R0   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of bottom of return stack
: RP   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of return stack pointer var
: IP   ( -- a)                       /ADD  CODE 'n_RDPFA' Address of instruction pointer var
: 0   ( -- 0)                        /P190 CODE 'n_RDPFA' const zero
: 1   ( -- 1)                        /P190 CODE 'n_RDPFA' const 1

----- store and fetch
: !   ( n a -- )                     /P190 CODE 'n_STORE'  store single number into addr
: @   ( a -- n)                      /P190 CODE 'n_FETCH'  replace addr with contents
: C!   ( b a -- )                    /P190 CODE 'n_STORE8' store 8 bit value
: C@   ( a -- b)                     /P190 CODE 'n_FETCH8' fetch 8 bit value

-------- Simple IO
: KEY?  ( -- ?)                      /ADD  CODE 'n_KEYN' Check if a key is waiting
: KEY   ( -- c)                      /P254 CODE 'n_KEY'  Get next char from input
: EMIT   ( c -- )                    /P26  CODE 'n_EMIT' Send character to output

-------- Data stack
: SWAP   ( n1 n2 -- n2 n1)           /P49  CODE 'n_SWAP' Reverse top two stack items
: DUP   ( n -- n n)                  /P49  CODE 'n_DUP'  Duplicate top stack item
: OVER   ( n1 n2 -- n1 n2 n1)        /P49  CODE 'n_OVER' Make a copy of second item and puts on top
: ROT   ( n1 n2 n3 -- n2 n3 n1)      /P49  CODE 'n_ROT'  Rotate 3rd item to top
: DROP   ( n -- )                    /P49  CODE 'n_DROP' Discard top item

-------- ALU
: +   ( n1 n2 -- n-sum)              /P49  CODE 'n_ADD'    Add
: -   ( n1 n2 -- n-diff)             /P49  CODE 'n_SUB'    Subtract (n1 - n2)
: AND   ( n1 n2 -- n-and)            /P92  CODE 'n_AND'    Logical AND
: OR   ( n1 n2 -- n-or)              /P92  CODE 'n_OR'     Logical OR
: XOR   ( n1 n2 -- n-xor)            /P92  CODE 'n_XOR'    Logical XOR
: *   ( n1 n2 -- n-prod)             /P49  CODE 'n_MULT'   Multiply
: /   ( n1 n2 -- n-quot)             /P49  CODE 'n_DIV'    Divide (n1/n2)
: MOD   ( n1 n2 -- n-rem)            /P49  CODE 'n_MOD'    Remainder from division (n1/n2)
: FLAGS  ( -- a)                     /ADD  CODE 'n_RDPFA'  Address of var of flags from last saved ALU operation
: FLAGS>   ( -- )                    /ADD  CODE 'n_FLAGS'  Save last ALU C,V,Z,P flags to FLAGS

----- low level branching
: BRANCH                             /ADD CODE 'n_BRANCH'  branch using relative offset following
: 0BRANCH                            /ADD CODE 'n_BRANCH0' branch if TOS=0, using relative offset following

-------- disk blocks
: BB0   ( -- a)                      /ADD CODE 'n_RDPFA' Lowest address of start of 1K block buffers
: BBN   ( -- #)                      /ADD CODE 'n_RDPFA' Number of 1K block buffers
: RBLK  ( n a -- )                   /ADD CODE 'n_RBLK'    Load 1K disk block n into memory at addr (see MMSForth)
: WBLK  ( n a -- )                   /ADD CODE 'n_WBLK'    Save 1K memory from addr to disk block n (see MMSForth)

----- running words
: DODOES                             /ADD CODE 'n_DODOES'
: NEXT                               /ADD CODE 'n_NEXT'
: ENTER                              /ADD CODE 'n_ENTER'
: EXECUTE                            /ADD CODE 'n_EXECUTE'

-- defining words
(note some of these are listed in 'synthesisable region too, need to resolve this)
: CREATE                             /??? CODE 'n_CREATE'
: :                                  /ADD CODE 'n_DOCOL'
: CONSTANT                           /ADD CODE 'n_DOCON'
: VARIABLE                           /ADD CODE 'n_DOVAR'
: LIT                                /ADD CODE 'n_DOLIT'


----- SYNTHESISABLE WORDS INTERFACE SPEC --------------------------------------

#### HERE ####

The rest of the words will be defined in terms of other words (high level forth words
that are synthesised). They may be replaced by native versions later to improve performance
once an initial language port is completed)

: HERE   ( -- a)                     /P213 n_DODOES  put value of H (next free dict addr) onto TOS
: UV0   ( -- a)                      /ADD  n_RDPFA   Address of start of user vars
: FALSE   ( -- 0)                    /P190 n_RDPFA   false (0)    : FALSE 0 ;
: TRUE   ( -- -1)                    /P190 n_RDPFA   true (-1)    : TRUE 0 1 - ;
: 2   ( -- 2)                        /ADD  n_RDPFA   const 2 (for simple shifts/multiplies) : 2 1 1 + ;
: (EXECUTE)   ( a -- )               /ADD  n_DODOES  execute from address (IP !)

/ might be synthesisable with new FLAGS feature
: */MOD   ( n1 n2 n3 -- n-rem n-result)   /P113 n_DODOES Multiply then divide, double length intermediate
: UM*   ( u1 u2 -- ud)               /P161 n_DODOES multiply 16 bit, 32 bit result
: UM/MOD   ( ud u1 -- u2 u3)         /P161 n_DODOES divide mod 16 bit, 32 bit result
: M*   ( n1 n2 -- d-prod)            /P161 n_DODOES multiply 16 bit, 32 bit result
: M+   ( d n -- d-sum)               /P161 n_DODOES 32bit add to 16 bit 32 bit result
: M/   ( d n -- n-quot)              /P161 n_DODOES 32bit divide 16 bit, 32 bit result
: M*/   ( d n u -- d)                /P161 n_DODOES mult 32 bit number by 16 bit, 32 bit result
: >R   ( n -- )                      /P113 n_DODOES Move data stack to return stack          : >R RP @ 1 + DUP ROT ! RP ! ;
: R>   ( -- n)                       /P113 n_DODOES Move return stack to data stack          : R> RP DUP @ @ SWAP 1 - RP ! ;
: R@   ( -- n)                       /P113 n_DODOES Copies top of return stack to data stack : R@ RP @ @ ;
: C?   ( -- ?)                       /ADD  n_DODOES query C flag in FLAGS var
: V?   ( -- ?)                       /ADD  n_DODOES query V flag in FLAGS var
: Z?   ( -- ?)                       /ADD  n_DODOES query Z flag in FLAGS var
: P?   ( -- ?)                       /ADD  n_DODOES query P flag in FLAGS var
: \ ( -- )                           /???  n_DODOES comment until next CR
: SP@   ( -- a)                      /P221 n_RDPFA (sp-fetch) Address of top data stack item)
: HERE   ( -- a)                     /P221 n_RDPFA Next available dictionary location (H @)
: IP ( -- n )                        /P204 n_RDPFA interpreter pointer
: I ( -- n)                          /P207 n_RDPFA loop counter
: J ( -- n)                          /P207 n_RDPFA loop counter
: 0.  ( -- 0 0)                      /P190 n_RDPFA  double length const 0 (0 0)
: D+   ( d1 d2 -- dsum)              /P161 n_DODOES adds 32 bit (synth if carry?)
: D-   ( d1 d2 -- d-diff)            /P161 n_DODOES subtracts 32 bit (synth if carry?)
: BINDEX ( -- a)                     /ADD  ADRVAR array of block buffer index info (0 not loaded)
: BLK   ( -- a)                      /P254 ADRVAR number of storage block being interpreted as input stream (0 means IN)
: (LOADED) ( n b ? -- )              /ADD  n_DODOES block buffer loaded or unloaded
: EXIT   ( -- )                      /P221 n_DODOES removes return addr from RS, return to it (or terminate defn)
: STATE   ( -- a)                    /P286 ADRVAR true if compiling, false if interpreting
: ?DUP   ( n -- n n) or ( 0 -- 0)    /P92  n_DODOES Duplicates only if n is nonzero
: BLANK   ( a # -- )                 /P254 n_DODOES fills with ascii 0
: MOVE   ( a1 a2 # -- )              /P254 n_DODOES copy region of memory
: CMOVE   ( a1 a2 # -- )             /P254 n_DODOES copy char region of memory
: CMOVE>   ( a1 a2 # -- )            /P254 n_DODOES copy char region of memory backwards
: FILL   ( a u b -- )                /P190 n_DODOES fills u bytes of memory
: ERASE   ( a u -- )                 /P190 n_DODOES zeros n bytes of memory
: DUMP   ( a u -- )                  /P190 n_DODOES display u bytes of memory
: HEX   ( -- )                       /P161 n_DODOES Base 16
: OCTAL   ( -- )                     /P161 n_DODOES Base 8
: DECIMAL   ( -- )                   /P161 n_DODOES Base 10
: TRIAD   ( n -- )                   /P77  n_DODOES Displays 3 blocks
: SHOW   ( lo hi -- )                /P77  n_DODOES Lists in triad form
: INDEX   ( lo hi -- )               /P77  n_DODOES Displays comment lines only
: COUNT   ( a -- a+1 #)              /P254 n_DODOES convert counted string into TYPE expected format
: CR   ( -- )                        /P26  n_DODOES Output a carriage return/line feed
: SPACES   ( n -- )                  /P26  n_DODOES Blank spaces
: SPACE   ( -- )                     /P26  n_DODOES One space
: FORGET name   ( -- )               /P77  n_DODOES Removes all dict entries up to and including this one
: 1+   ( n -- n+1)                   /P113 n_DODOES Add one
: 1-   ( n -- n-1)                   /P113 n_DODOES Subtract one
: 2+   ( n -- n+2)                   /P113 n_DODOES Add two
: 2-   ( n -- n-2)                   /P113 n_DODOES Subtract two
: 2*   ( n -- n*2)                   /P113 n_DODOES Multiply by two
: 2/   ( n -- n/2)                   /P113 n_DODOES Divide by two
: ABS   ( n -- |n|)                  /P113 n_DODOES Absolute value
: NEGATE   ( n -- -n)                /P113 n_DODOES Change the sign
: MIN   ( n1 n2 -- min)              /P113 n_DODOES Minimum
: MAX   ( n1 n2 -- max)              /P113 n_DODOES Maximum
: <#                                 /P161 n_DODOES Begin number conversion
: #                                  /P161 n_DODOES Convert one digit into output char string
: #S                                 /P161 n_DODOES Convert until result is zero
: c HOLD                             /P161 n_DODOES Insert char
: n SIGN                             /P161 n_DODOES Insert minus sign
: #>                                 /P161 n_DODOES End conversion
: <# ... #>   ( d -- a u)            /P161 n_DODOES 32 bit unsigned
              ( u 0 -- a u)          /P161 n_DODOES 16 bit signed
: <# ... n SIGN #>   ( |d| -- a u)   /P161 n_DODOES 32 bit signed
                or   ( |d| 0 -- a u) /P161 n_DODOES 16 bit signed
: CONSTANT xxx   ( n -- )            /P190 n_DODOES create constant with a value
           xxx:  ( -- n)
: VARIABLE xxx   ( -- )              /P190 n_DODOES create variable (returns addr when exec)
           xxx: ( -- a)
: 2VARIABLE xxx   ( -- )             /P190 n_DODOES create double length var, addr when exec
            xxx:  ( -- a)
: 2CONSTANT xxx   ( d -- )           /P190 n_DODOES create double length const with value
            xxx:  ( -- d)
: PAGE   ( -- )                      /P131 n_DODOES Clears display and resets to left top
: RECURSE ( -- )                     /P211 n_DODOES compile address of the word being defined, to allow recursion
: CONTEXT   ( -- a)                  /P221 n_DODOES address of var that specifies dict search order
: CURRENT   ( -- a)                  /P221 n_DODOES addr of var specifying the vocab for new defns
: FORTH   ( -- )                     /P221 n_DODOES Make forth context vocab
: EDITOR   ( -- )                    /P221 n_DODOES Make editor the context vocab
: ASSEMBLER   ( -- )                 /P221 n_DODOES Make assembler the context vocab
: DEFINITIONS   ( -- )               /P221 n_DODOES sets current vocab to context vocab
: ." xxx"   ( -- )                   /P26  n_DODOES Displays the character string xxx. The " character terminates the string
: .   ( n -- )                       /P26  n_DODOES Display number followed by a space
: ( xxx)   ( -- )                    /P26  n_DODOES Comment, terminated by )
: LIST   ( n -- )                    /P77  n_DODOES Lists a disk block
: .( text)   ( -- )                  /P77  n_DODOES Display text
: THRU   ( lo hi -- )                /P77  n_DODOES Loads all blocks inclusive
: ABORT" xxx"   ( ? -- )             /P92  n_DODOES If flag true, shows last word and text, clears user stacks, back to terminal.
: BLOCK   ( u -- a)                  /P254 n_DODOES Address of first byte in block
: BUFFER   ( u -- a)                 /P254 n_DODOES like block, not necc read from mass storage
: TYPE   ( a # -- )                  /P254 n_DODOES transmits # chars starting at addr
: -TRAILING   (a #1 -- a #2)         /P254 n_DODOES eliminates trailing blanks from string
: PAD   ( -- a)                      /P221 ADRVAR addr of scratch area start
: >TYPE   ( a # -- )                 /P254 n_DODOES output string moved to PAD before output
: -TEXT   ( a1 # a2 -- ?)            /P254 n_DODOES compare strings
: -MATCH   ( d # s # -- a ?)         /P254 n_DODOES search for string
: TIB   ( -- a)                      /P221 ADRVAR Address of start of text input buffer
: >IN   ( -- a)                      /P254 ADRVAR present char offset in input stream
: EXPECT   ( a # -- )                /P254 n_DODOES wait for chars or newline
: SPAN   ( -- a)                     /P254 ADRVAR number of chars read in expect
: IMMEDIATE   ( -- )                 /P286 n_DODOES marks recently defined word by setting immediate bit
: INTERPRET   ( -- )                 /P286 n_DODOES text interpret input stream until exhausted
: >BODY   ( cfa -- pfa)              /P221 n_DODOES pfa address of cfa address
: @EXECUTE   ( a -- )                /P221 n_DODOES executes dict entry pfa pointed to by contents of a, nothing if zero
: STRING   ( c -- )                  /P254 n_DODOES compiles string literal into dict as counted string
: NOT   (? -- -?)                    /P92  n_DODOES Reverse sense of flag
: =   ( n1 n2 -- ?)                  /P92  n_DODOES True if n1 and n2 are equal
: <>   ( n1 n2 -- ?)                 /P92  n_DODOES True if n1 and n2 are not equal
: <   ( n1 n2 -- ?)                  /P92  n_DODOES True if ni less than n2
: U<   ( u1 u2 -- ?)                 /P161 n_DODOES Unsigned compare (use sub)
: >   ( n1 n2 -- ?)                  /P92  n_DODOES True if n1 greater than n2
: 0=   ( n -- ?)                     /P92  n_DODOES True if n is zero
: 0<   ( n -- ?)                     /P92  n_DODOES True if n is negative
: 0>   ( n -- ?)                     /P92  n_DODOES True if n is positive
: D0=   ( d -- ?)                    /P161 n_DODOES true if zero
: D=   ( d1 d2 -- ?)                 /P161 n_DODOES equality check
: D<   ( d1 d2 -- ?)                 /P161 n_DODOES true if less
: DU<   (ud1 ud2 -- ?)               /P161 n_DODOES true if unsigned less
: DNEGATE   ( d -- -d)               /P161 n_DODOES negates 32 bit
: DABS   ( d -- |d|)                 /P161 n_DODOES absolute of 32 bit
: DMAX   ( d1 d2 -- d-max)           /P161 n_DODOES max of 32 bit
: DMIN   ( d1 d2 -- d-min)           /P161 n_DODOES min of 32 bit
: ALLOT   ( n -- )                   /P190 n_DODOES adds n bytes to parameter field of most recently defined word
: ,   ( n -- )                       /P190 n_DODOES compiles n into next available cell in dict
: C,   ( b -- )                      /P190 n_DODOES compiles b into next available byte in dict
: +!   ( n a -- )                    /P190 n_DODOES add single len number to contents of addr
: 2!   ( d a -- )                    /P190 n_DODOES store double length number
: 2@   ( a -- d)                     /P190 n_DODOES return double length contents
: U.R   ( u width -- )               /P161 n_DODOES Print unsigned number right justified
: .R   ( n width -- )                /P131 n_DODOES Prints number right justified to width
: D.R   ( d width -- )               /P161 n_DODOES print 32 bit number right justified
: /MOD   ( n1 n2 -- n-rem n-quot)    /P49  n_DODOES Divides, remainder and quotient
: */   ( n1 n2 n3 -- result)         /P113 n_DODOES Multply then divide, 32bit intermediate
: 2SWAP   ( d1 d2 -- d2 d1)          /P49  n_DODOES Reverses top two pairs of numbers
: 2DUP   ( d -- d d)                 /P49  n_DODOES Duplicates top pair of numbers
: 2OVER   ( d1 d2 -- d1 d2 d1)       /P49  n_DODOES Duplicates top pairs of numbers
: 2DROP   ( d --)                    /P49  n_DODOES Discards top pair of numbers
: WORD   ( c -- a)                   /P254 n_DODOES read 1 word from input stream
: LIT" xxx"   run-time: ( -- a)      /P254 n_DODOES compiles literal (used in definitions)
: QUIT   ( -- )                      /P221 n_DODOES clear RS, back to monitor
: ABORT   ( -- )                     /P221 n_DODOES Clear DS and then quit
: ASCII   ( -- c)                    /P161 n_DODOES Next input char into ascii equivalent
: CONVERT   ( ud1 a1 -- ud2 a2)      /P254 n_DODOES string to binary value
: BASE   ( -- a)                     /P190 ADRVAR number base
: NUMBER   ( a -- d)                 /P254 n_DODOES using base, convert to binary value
: LOAD   ( n -- )                    /P77  n_DODOES Loads a disk block (compiles or executes) assume (LOAD)
: FLUSH   ( -- )                     /P77  n_DODOES Writes all updated disk buffers to disk, and unassigns
: LOCATE xxx   ( -- )                /P77  n_DODOES Lists block from which xxx has been loaded
: VIEW xxx   ( -- )                  /P77  n_DODOES Lists block from which xxx has been loaded
: UPDATE   ( -- )                    /P254 n_DODOES Most recently referenced block marked modified
: SAVE-BUFFERS   ( -- )              /P254 n_DODOES Writes all updated buffers, un-updated, still assigned
: FLUSH   ( -- )                     /P254 n_DODOES saves then unassigns all buffers
: EMPTY-BUFFERS   ( -- )             /P254 n_DODOES marks all buffers empty without saving
: [']   compile-time: ( -- )         /P221 n_DODOES compiles address of next word in defn as a literal
        run-time: ( -- a)
: LITERAL   compile-time: ( n -- )   /P286 n_DODOES compiles a value
            run-time: ( -- n)
: [   ( -- )                         /P286 n_DODOES leaves compile mode
: ]   ( -- )                         /P286 n_DODOES enters compile mode
: COMPILE xxx   ( -- )               /P286 n_DODOES compile a word
: [COMPILE] xxx   ( -- )             /P286 n_DODOES immediate word gets compiled
: EXECUTE   ( a -- )                 /P221 n_DODOES executes dict entry pfa on stack
: CREATE xxx   ( -- )                /P190 n_DODOES create dictionary header, (xxx returns addr when exec)
         xxx:  ( -- a)
: DOES>   run-time: ( -- a)          /P286 n_DODOES creates defining word, end of compile-time begin of run-time
: ; ( -- )                           /ADD  n_DODOES end of definition (compile exit, so ' EXIT)
: D.   ( d -- )                      /P161 n_DODOES print 32 bit number and 1 space
: ?   ( a -- )                       /P190 n_DODOES prints contents of addr followed by 1 space
: U.   ( u -- )                      /P161 n_DODOES Print unsigned number and space
: ' xxx   ( -- a)                    /P221 n_DODOES find dict address of xxx
: IF xxx   IF: ( ? -- )              /P92  n_DODOES If non zero, executes xxx, otherwise yyy, continues with zzz
  ELSE yyy
  THEN zzz
: DO ... LOOP   DO:                  /P131 n_DODOES Finite loop
                  ( limit index -- )
                LOOP:  ( -- )
: DO ... +LOOP  DO:                  /P131 DODOES Finite stepped loop
                  ( limit index -- )
                +LOOP:  ( n -- )
: LEAVE   ( -- )                     /P131 DODOES Terminate at next LOOP
: BEGIN ... UNTIL   UNTIL: ( ? -- )  /P131 DODOES Indefinite loop exits when ? true
: BEGIN xxx WHILE yyy REPEAT   WHILE:  ( ? -- )   /P131 DODOES Indefinite loop always executes xxx


===== IMPLEMENTATION SPEC =====================================================

----- BEHAVIOUR SPEC OF NATIVE ROUTINES ---------------------------------------

NOTE: the real problem here is that CFA can only ever point to a native routine,
never a threaded instruction list. So, the 'base' code must always be native.
This *might* make it impossible to boot a minimal kernel then extend it incrementally
unless we look into this.


---- READ/WRITE

/todo: endianness?
/pre: stack has at least 2 16-bit items
/pre: address is 16 bit aligned
: n_STORE   ( n a -- )   { a=ds_pop; n0=ds_pop8; n1=ds_pop8; mem[a]=n0; mem[a+1]=n1} ;

/todo: endianness?
/pre: stack has at least 1 16-bit items
: n_FETCH  ( a -- n)   { a=ds_pop; n0=mem[a]; n1=mem[a+1]; ds_push8(n0); ds_push8(n1) } ;

/pre: stack has at least 3 8 bit items
: n_STORE8  ( b a -- )   { a=ds_pop; b=ds_pop8; mem[a]=b } ;

/pre: stack has at least 1 16 bit item
: n_FETCH8   ( a -- b)   { a=ds_pop; b=mem[a]; ds_push8(b) } ;


---- I/O

: n_KEYQ   ( -- ?)   { ds_push8(kbhit) } ;         / how many chars waiting in input stream (could be 0/1 if no lookahead)

: n_KEY   ( -- c)   { ds_push8(getch) } ;          / read next char in input stream, or block

: n_EMIT   ( c -- )   { putch(ds_pop8) } ;        / output 1 char to output stream, block if full


---- ALU

/pre: stack has at least 2 16 bit items
: n_ADD   ( n1 n2 -- n-sum)   { n2=ds_pop; n1=ds_pop; r=n1+n2; flags=zncv; ds_push(r) } ;

/pre: stack has at least 2 16 bit items
: n_SUB   ( n1 n2 -- n-diff)   { n2=ds_pop; n1=ds_pop; r=n1-n2; flags=zncv; ds_push(r) } ;

/pre: stack has at least 2 16 bit items
: n_AND   ( n1 n2 -- n-and)   { n2=ds_pop; n1=ds_pop; r=n1 and n2; flags=zncv; ds_push(r) } ;

/pre: stack has at least 2 16 bit items
: n_OR   ( n1 n2 -- n-or)   { n2=ds_pop; n1=ds_pop; r=n1 or n2; flags=zncv; ds_push(r) } ;

/pre: stack has at least 2 16 bit items
: n_XOR   ( n1 n2 -- n-xor)   { n2=ds_pop; n1=ds_pop; r=n1 xor n2; flags=zncv; ds_push(r) } ;

/pre: stack has at least 2 16 bit items
: n_MULT   ( n1 n2 -- n-prod)   { n2=ds_pop; n1=ds_pop; r=n1*n2; flags=zncv; ds_push(r) } ;

/pre: stack has at least 2 16 bit items
: n_DIV   ( n1 n2 -- n-quot)   { n2=ds_pop; n2=ds_pop; r=n1/n2; flags=zncv; ds_push(c) } ;

/pre: stack has at least 2 16 bit items
: n_MOD   ( n1 n2 -- n-rem)   { n2=ds_pop; n1=ds_pop; r=n1 mod n2; flags=zncv; ds_push(r) } ;

: n_FLAGS   ( -- )   { mem[FLAGS]=flags } ;


--- DATA STACK

TODO: accessing DP will need to be done via a native, as it's an internal register

: n_SWAP   ( n1 n2 -- n2 n1)   { n2=ds_pop; n1=ds_pop; ds_push(n2); ds_push(n1) } ;

/todo: check if dp is next free, or last used
: n_DUP   ( n -- n n)   { n = ds[dp]; ds_push(n) } ;

/todo: check if dp is next free, or last used
/todo: check direction of growth of dp
: n_OVER   ( n1 n2 -- n1 n2 n1)   { n1=ds[dp-2]; ds_push(n1) } ;

: n_ROT   ( n1 n2 n3 -- n2 n3 n1)   { n3=ds_pop; n2=ds_pop; n1=ds_pop; ds_push(n2); ds_push(n3); ds_push(n1) } ;

: n_DROP   ( n -- )   { ds_pop } ;


---- DISK ACCESS

/pre: at least two 16 bit items on stack
/pre: disk block is in range
: n_RBLK  ( n a -- )   { a=ds_pop; n=ds_pop; b=disk_rd(1024*b, mem, a, 1024) } ;       / Load 1K disk block n into memory at addr (see MMSForth)

/pre: at least two 16 bit items on stack
/pre: disk block is in range
: n_WBLK  ( n a -- )   { a=ds_pop; n=ds_pop; disk_wr(1024*b, mem, a, 1024) } ;       / Save 1K memory from addr to disk block n (see MMSForth)





----- BEHAVIOUR CAN BE DEFINED IN HIGH LEVEL WORDS ----------------------------


---- BRANCHING

Behaviour can be defined in high level

as a callable word:
: BRANCH   ( -- ) R@ DUP @ - IP !  ;  / unconditional branch using relative offset in following cell (IP points to it)

/pre: stack has at least 1 byte on it
: n_0BRANCH   ( ? -- )
        { f=ds_pop; r=mem[ip]; if f==0:ip=ip-r else: ip+=2 } ; / branch if TOS=0, using relative offset following


---- VARIABLE ACCESS

Can use to read system variable address, or constant value

/pre: at least 1 16-bit value on DS
/pre: address is 16 bit aligned?
: n_RDPFA   ( a-pfa -- n)   { pfa=ds_pop; r=mem[pfa]; ds_push(r) } ;     / read constant out from PFA and push to DS


/pre: at least 1 16-bit value on DS
/pre: address is 16 bit aligned?

: n_ADRUV   ( a-pfa -- a)   { pfa=ds_pop; rel=mem[pfa]; a=uservars+rel; ds_push(a) } ;       / get address of user variable from offset in PFA and push to DS


---- EXECUTION

Note, all of these can be defined as high level routines

/assume: indirect code points to CFA of word
: NEXT   ( -- )
        / run next high level addr pointed to by IP
        /   IP DUP @ 1 + >R @ ( cfa )   / increment IP, put on return stack, get what at IP which is a CFA of word to execute
        / @ IP @ 1 + IP ! ( code )      / get address to jump to, increment IP to point to PFA
        / JSR                           / call machine code routine, which knows how to interpret from IP


: DODOES   ( -- ) { } ;          / (PFA containing high level thread of CFA addresses, sometimes called ENTER,
                                   / runs high level forth code)
        /                          / repeatedly call NEXT to execute


: EXECUTE   ( -- ) { } ;         / ??? high level? does this do anything extra to above?)

: LIT   ( -- ) { } ;             / put LIT in next IP address on TOS) - is this a native routine or a high level routine?

: EXIT   ( -- ) { ip=rs_pop() } ;


---- CREATIONAL

behaviour of these can *probably* be defined in high level words

: CREATE   ( -- ) { } ;    / root of all creation words, creates a new dict entry

: DOCOL   ( -- ) { } ;     / colon definition, define a new high level word)

: DOCON   ( -- ) { } ;     / ??constant value)

: DOVAR   ( -- ) { } ;     / ??storage for a var) what about uservar and sysvar differences?

: DOVOC   ( -- ) { } ;     / something to do with vocabulary change? could be synthesised?)

: DOLIT   ( -- ) { } ;     / compile a literal at H?)
                             / I thought the DO words were runtime behaviour, not compile time behaviour.
                             / TODO: Do we need a naming convention for compile time words and runtime words?
                             / Remember the immediate bit in the count byte?



===== BEHAVIOUR SPEC OF HIGH LEVEL ROUTINES ===================================

for each word in the synthesisable list, need to show:
- DS before and after
- RS before and after
- DICT before and after
- other side effects
- write a colon definition of it, regardless of whether we will synthesise
  it as a high level word, or write it as a native. It will form a complete
  spec of behaviour. We can resolve dependencies and inefficiencies later.

  In fact, any word could be defined this way, even some of the native ones?
  No point with ALU ops, but some of the others could be specified that way.

===============================================================================
OTHER STUFF, STILL WORKING OUT WHERE IT GOES.

--------
CONSTANT and 2CONSTANT

A constant is compiled into the DICT as follows:

@addr
  name: b NAME
  link: prev
  cfa: @PFA
  pfa: [VALUE]

A 2constant is compiled into the DICT as follows:

@addr
  name: b NAME
  link: prev
  cfa: 2@PFA
  pfa: [VALUEA,VALUEB]

: CFA   ( a-name -- a-cfa)   DUP C@ + 1 + ;
: PFA   ( a-name -- a-pfa)   DUP C@ + 3 + ;
: @PFA   ( a-pfa -- n)   PFA @ ;
: 2@PFA   ( a-pfa -- d)   PFA DUP @ 1 + @ ;

: CONSTANT   ( n -- ) ( name) DOES> ; / TODO
: 2CONSTANT   ( d -- ) ( name) DOES> ; / TODO


---------
VARIABLE and 2VARIABLE

A variable is compiled into the DICT as follows:

@addr
  name: b NAME
  link: prev
  cfa:  PFA
  pfa:  [SPACE]

@addr
  name: b NAME
  link: prev
  cfa: PFA
  pfa [SPACEA, SPACEB]


: VARIABLE   ( -- ) ( name)     DOES> ;
: 2VARIABLE   ( -- ) ( name)    DOES> ;

--------
CODE (non native, i.e. threaded addresses)
  DICT holds {name, link=prev, cfa=pfa, pfa=[code,code,exit]}
  space is ALLOTed inside the pfa of the dict entry for code and final exit (addrs) using COMPILE

HOW CODE works... (BRODIE P205)

EXECUTE of a word will call the machine code pointed to by CFA.
: EXECUTE
  reads cell at IP, pushes value on DS
  adds 1 to IP
  uses cell addr on DS as the CFA of the defined word
  jumps to machinecode routine (special case 0 here does nothing?)

  For defined words, this is a machine code routine for ':'

  ':' is defined in machine code as:
    saves IP onto return stack
    move address of PFA into IP
    call EXECUTE

@addr
  name: b NAME
  link: prev
  cfa: PFA
  pfa: [CODE, CODE, ..., EXIT]

note, interpret loop is:
: INTERPRET ( -- ) BEGIN IP DUP @ SWAP 1 + >R IP ! FALSE UNTIL ;
: EXIT   ( -- )   R> IP ! ;

--------
LITERALS

pfa: [(LITERAL), 65535]
pfa: [(2LITERAL), 65535, 65535]

: (LITERAL)   ( -- n)   R> DUP @ SWAP 1 + IP ! ;
: (2LITERAL)   ( -- d)   R> DUP @ SWAP 1 + @ SWAP 1 + IP ! ;

: LITERAL   ( n -- )   DOES> ; / TODO
: 2LITERAL   ( d -- )  DOES> ; / TODO

/ do all the hard work at compile time
: BEGIN  ( -- )    HERE >R DOES> ;
: UNTIL   ( ? -- )   R> , DOES> (0BRANCH) ;


--------



  LFA Link field points to name field of previous entry

  threads stored in the PFA are pointers to the CFA of the linked word,
  so that no additional maths is required on following the link.

  CFA is a pointer to a machine code routine.

  H points to the last used entry of the dict.
  HERE puts the address stored in H on TOS
  ' gets the PFA address of the word (so that you can write directly to it)
  ! assumes the address is of the bytes to write to
  @ assumes the address on TOS is of the bytes to read from













